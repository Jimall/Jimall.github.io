<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BLOG</title><link>https://Jimall.github.io/</link><description>Recent content on BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 03 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://Jimall.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring IoC 组件详解</title><link>https://Jimall.github.io/tech/posts/java/spring/ioc/spring%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/java/spring/ioc/spring%E7%AC%94%E8%AE%B0/</guid><description>Spring 有两大核心机制：
IoC (Inverse of Control, 控制反转) AOP (Aspect-Oriented Programming, 面向切面编程) 学习 Spring 的核心（单指 Spring 本身，不包括别的组件）就在于学习理解这两大核心机制。
这篇文章我们来讲讲 IoC。
IoC IoC 是 Spring 的核心机制。
什么是 IoC？ IoC (Inversion of Control)，即“控制反转”。它不是一种技术，而是一种设计思想。在 Java 开发中，IoC 意味着将你设计好的对象交给容器控制，而不是在你的对象内部控制（控制的意思是说对象内部需要通过 new 等方式创建依赖对象，需要我们自己进行创建）。
如何理解好 IoC 呢？理解好 Ioc 的关键是要明确”谁控制谁？控制什么？为何是反转？哪些方面反转了？”：
”谁控制谁？控制什么？“：在传统 Java SE 程序设计中，我们直接在对象内部通过 new 创建对象，是对象主动去创建依赖对象，而 IoC 通过一个专门的容器（称为 IoC 容器）来创建这些对象；谁控制谁？IoC 容器控制了对象；控制什么？控制了外部资源获取（不只是对象包括比如文件等）。
“为何是反转？哪些方面反转了？”：有反转就有正转，传统应用程序由我们自己在程序中主动控制去获取依赖对象，也就是正转，而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取反转。
所以控制反转的意思就是，IoC 容器控制对象，让依赖对象的获取反转。
IoC 能做什么？ IoC 不是一种技术，而是一种设计思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试。有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。
IoC 很好的体现了面向对象设计法则中的好莱坞法则：“别找我们，我们找你”，即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。
DI DI (Dependency Injection) 依赖注入。这也是 Spring 中的一个重要概念。</description></item><item><title>Spring结合Junit进行单元测试</title><link>https://Jimall.github.io/tech/posts/java/spring/spring%E7%BB%93%E5%90%88junit%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/java/spring/spring%E7%BB%93%E5%90%88junit%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>由于 Spring 各种注解的使用需要结合 xml 配置文件，所以单元测试没有办法直接写，需要引入 Spring 对单元测试的支持。下面讲讲详细步骤：
引入 Spring-test 和 junit test 依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.13&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.9.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 在测试类中添加 @RunWith 和 @ContextConfiguration 注解
@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&amp;quot;classpath:spring.xml&amp;quot;) public class StudentTest { @Autowired public Student student; @Test public void testStudentCreation() { System.out.println(student); } } 这样就可以正常使用了，需要注意的是，spring.xml 中需要配置才能使用 @Autowired 等注解：
&amp;lt;context:component-scan base-package=&amp;quot;org.example&amp;quot;/&amp;gt; （同时 xml 文件头还需要引入 context 相关的域，alt+enter 即可）</description></item><item><title>Java 集合框架 Map 接口</title><link>https://Jimall.github.io/tech/posts/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/map%E6%8E%A5%E5%8F%A3/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/map%E6%8E%A5%E5%8F%A3/</guid><description>图示：
Map 通过 key-value 形式存元素，每个元素称为 entry，即一个 entry 包含 key 和 value 两个值。
Map 接口 api 信息：isEmpty(), size()
添加修改：put(key, value) 如果 key 存在就会修改，否则添加
查找：containKey(), containValue()
遍历：entrySet() 返回映射关系的 set 视图，keySet() 返回 key 的 set 视图，values() 返回 value 的 collection 视图
删除：remove(key)，clear()
常用集合 HashMap 了解 HashMap，首先需要了解哈希算法：
哈希冲突及四种解决方法
四种解决方法：
开放地址法 1.
拉链法
建立公共溢出区
建立公共溢出区存储所有哈希冲突的数据。
再哈希法
然后需要了解红黑树：
红黑树介绍和实现
总结：
红黑树是平衡的二叉查找树，和 AVL tree 是类似的，不同的是 AVL tree 和红黑树维持平衡的规则不太一样。 红黑树的关键性质： 每个结点要么是红的要么是黑的。 根结点是黑的。 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。 如果一个结点是红的，那么它的两个儿子都是黑的。 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 理解红黑树的关键是理解平衡和理解二叉查找树，二叉查找树插入、删除和查找的开销都是 O(h)，由于红黑树平衡，那么 h 最大为 log(n)，所以红黑树插入、删除和查找的开销为 log(n) 开始看 HashMap 解析博文，根据博文再看 HashMap 源码进行理解：</description></item><item><title>Leetcode-086-分隔链表</title><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</guid><description>题目链接：
https://leetcode-cn.com/problems/partition-list/
tag：链表 虚拟头
关键是构造小大两个链表，然后串起来。只要想到这个思路，代码实现就很简单了。
注意串的时候，需要将大链表的尾部设为 null，不然会成环。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode partition(ListNode head, int x) { ListNode current = head; ListNode dummySmall = new ListNode(); ListNode currentSmall = dummySmall; ListNode dummyLarge = new ListNode(); ListNode currentLarge = dummyLarge; while (current !</description></item><item><title>Leetcode-092-反转链表II</title><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</guid><description>题目链接：
https://leetcode-cn.com/problems/reverse-linked-list-ii/
tag：链表
在串中，部分反转可以通过先部分反转，再整体反转的思路来进行。链表部分反转也是一样的，不过链表部分反转之后通过穿针引线的方式串回原链表即可，不需要进行反转。
具体实现就是，首先切割出子链表，然后反转子链表，最后串起来。切割子链表这里的操作需要注意、
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { // 虚拟头 ListNode dummy = new ListNode(); dummy.next = head; ListNode leftNode = dummy; // 获得左节点右节点和边界节点 for (int i = 0; i &amp;lt; left - 1; i++) { leftNode = leftNode.</description></item><item><title>Leetcode-206-反转链表</title><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>题目链接：
https://leetcode-cn.com/problems/reverse-linked-list/
tag：链表
链表反转的关键在于记录前驱节点 prev，想到这点就很快能做出来。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; while (current != null) { ListNode next = current.</description></item><item><title>TypeScript 简明教程</title><link>https://Jimall.github.io/tech/posts/frontend/typescript/typescript-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/frontend/typescript/typescript-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</guid><description>TypeScript 是 JavaScript 的超集，能够用类似写 Java 的体验（更准确说来更像 Kotlin）来写 JavaScript，很方便很快捷。
TypeScript 类型 TypeScript 的数据类型分为 boolean, number, string, array, tuple, enum, object, null, undefined, any, void, never
布尔（boolean）类型
let flag: boolean = false 有 true 和 false 两个值
数字（number）类型
let num1: number = 1 let num2: number = 1.8 let num3: number = -1 各种数字都是 number 类型，并且支持二进制八进制和十六进制值
字符串（string）类型
let name: string = &amp;quot;typescript&amp;quot; 支持模板字符串，用反引号</description></item><item><title>加密算法</title><link>https://Jimall.github.io/tech/posts/06.encryption/</link><pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/06.encryption/</guid><description>加密算法涉及一些概念：数字签名、数据加密解密、加密算法、对称加密算法、非对称加密算法、单向加密算法。下面进行介绍。
加密和解密 加密和解密主要是为了防止传输过程中的数据泄露，因为传输过程中不免会被抓包什么的。
数据加密的基本过程，就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为密文。这样，发送的过程中，不会被非法人窃取，因为别人看不懂加密后的东西是啥。
加密的逆过程为解密，即将”密文“转化为其原来数据的过程，因为传输后需要使用数据，不可能用加密后的看不懂的密文。
加密算法及应用 加密算法分为对称加密算法、非对称加密算法、单向加密算法。
对称加密算法 对称加密算法是应用较早的加密算法，又称为共享密钥加密算法。在对称加密算法中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行加密和解密。这就要求加密和解密方事先都必须知道加密的密钥。
数据加密过程：在对称加密算法中，数据发送方将明文（原始数据）和加密密钥一起经过特殊加密处理，生成复杂的加密密文进行发送。
数据解密过程：数据接收方收到密文后，若想读取原数据，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。
这个道理可以这样理解：我们写 markdown，规则定好了，比如 # 表示一级标题（相当于秘钥），所以我这边就这样写一级标题（加密），然后发给你，因为采用一样的规则，你也解读成一级标题（解密），这样信息在两边就相同了。有人看到了我写的东西（密文），但是他不知道这个规则，他就不知道我写的东西究竟是啥。
对称加密算法的优缺点：
优点：操作比较简单，加密速度快，秘钥简单。经常在消息发送方需要加密大量数据时使用。 缺点：秘钥存在传输泄露风险。因为新增一个协作方的时候，它需要秘钥来进行加密和解密，所以我们要把秘钥发给对方，那么这个过程中秘钥如果泄露，无论谁给我们发消息，获取秘钥的人都可以用这个秘钥去解密，相当于没有加密发消息（类似于抗战时期我方的密码本被敌方截获了，那敌方肯定啥都知道了）。 常用对称加密算法：DES，3DES，AES 等。在 jdk 中都有封装。
非对称加密算法 非对称加密算法，又称为公开密钥加密算法，顾名思义就是加密与解密的过程不是对称的，不使用同一个秘钥。它需要两个密钥，一个称为公开密钥 (public key)，即公钥，另一个称为私有密钥 (private key)，即私钥。公钥和私钥是结对的，生成的时候会生成一对公私钥对。
这种算法的特点是：
使用公钥对数据进行加密，只有用对应的私钥才能进行解密。 使用私钥对数据进行加密，只有用对应的公钥才能进行解密。 这里的关键点在于，公钥加密的消息只能私钥解密。使用时由接收方生成公私钥对，然后将公钥传给发送方，私钥保存在服务器上，不进行任何传输，这样就不会泄露（除非有内鬼）。这种情况下，和对称加密不同，公钥可以随意分发给发送方，甚至泄漏到网上也没事，一个黑客拿着公钥没有办法解读别人发给我们的信息，所以秘钥的传输是安全的，不用担心泄露，解决了对称传输中秘钥传输泄露的问题。
非对称算法的缺点在于运算速度较慢。
常用的非对称加密算法有：RSA、DSA、ECC 等。
单向加密算法 单向加密算法又称为不可逆加密算法，实际上就是哈希算法。它只能对明文数据进行加密，而不能对加密了的密文数据再解密成原来的明文数据，所以称为单向加密。
单向加密的特点也就是哈希算法的特点：
任意两段明文数据，加密以后的密文数据一定是不相同的 任意一段明文数据，经过加密以后，其密文数据永远是相同的 单向加密的关键在于其应用：
当用户注册一个新的账号时，其用户密码信息不是直接保存到数据库，而是经过单向加密后再保存，这样，即使这些账号信息被泄露，别人也不能得到相应的用户密码，因为单向加密没有办法进行解密，当然也就达不到盗窃账号的目的。 用户 Login 的时候，系统对用户输入的密码进行单向加密，然后再去和系统中保存的加密值进行比较，但系统中并没有存明文密码，所以我们不会知道密码是什么。 由于一样的文件，产生加密值是相同的，所以可以进行文件完整性检测。 常用的单向加密算法有 MD5、SHA
提到单向加密算法经常会提到 BASE64 编码。目前 BASE64 已经成为网络上常见的传输 8Bit 字节代码的编码方式之一。
在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64 的出现就是为了解决此问题，它是基于 64 个可打印的字符来表示二进制的数据的一种方法。
电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此 Base64 就登场了。随之，Base64 在 URL、Cookie、网页传输少量二进制文件中也有相应的使用。</description></item><item><title>git submodule 的使用</title><link>https://Jimall.github.io/tech/posts/05.gitsubmodule/</link><pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/05.gitsubmodule/</guid><description>在 Git 项目中，需要包含别的 Git 项目，我们希望能够独立的使用这两个项目。比如我们的博客是一个 Git 项目，而我们需要在博客中包含别人的项目作为博客主题，我们希望能够在自己写博文后 push 不影响博客主题仓库，同时希望能够独立使用主题仓库，这样我们就可以获取最新的主题。
这个时候需要用到 git submodule。在使用 submodule 之后，两个项目便相对独立（或者多个 submodule，那么就是多个项目相对独立）。下面介绍子模块常用的用法：
使用子模块 添加子模块 在 Git 项目中包含别的 Git 项目，不能够直接到相应文件夹 clone，而需要使用 git add submodule 命令，可以将这个命令视为子模块版本的 git clone。
git add submodule git@github.com/example/example.git submodule 上面的命令将项目克隆到 submodule 目录。会发现根目录生成了一个 .gitmodule 文件，这个文件用于保存子模块信息。
查看子模块 使用 git submodule 命令查看当前项目的子模块。
更新子模块 在项目中使用 git update 父模块并不会更新子模块。（别的操作同理，我们在项目中使用的各种以前使用的 git 操作都只会对父模块产生作用）
使用 git submodule add 添加子项目。
操作子模块 在子模块的文件夹内部，我们的各种操作都是对子模块的项目产生作用，比如 push 就是将子模块 push 到子模块的 remote repository。
所以需要单独修改子模块，只需要 cd 到子模块内，把子模块当成一个普通的 git 项目即可。</description></item><item><title>使用 Github actions 自动发布 Hugo 博客</title><link>https://Jimall.github.io/tech/posts/04.hugoactions/</link><pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/04.hugoactions/</guid><description>使用 hugo 写博客的时候，每次增加文章，需要本地构建之后发布到 github 上通过 github pages 服务展示页面，不难想到可以使用 CI 的方法，将构建的过程自动化，实现写博文 push 到 github 即可自动构建并发布到 github pages。
搞的过程中坑比较多，记录为一个教程，供各位参考。
我折腾过程中的参考：https://tianhui.xin/blog/2019/11/17/hugousegithubactionstopages/
创建代码仓库和 github pages 仓库 构建过程中采用两个仓库：
代码仓库，github pages 在这里构建并发布，我们设为 username.github.io.source github pages 仓库，用于存放构建好的文件，github pages 服务会根据构建好的文件展示我们的博。客，我们设为 username.github.io （username 改为你自己的 github username） 简单说来就是根据代码仓库的文件构建，构建好之后发布到 github pages 仓库，github pages 仓库由于有 github 提供的服务，会自动展示我们的 blog。
创建 github pages 仓库 没啥特别，github 上创建一个空仓库 username.github.io
创建代码仓库 这个仓库和我们本地直接关联，创建有一些细节需要注意，我下面的过程给各位参考：
github 创建空仓库 username.github.io.source
本地找个空文件夹，比如叫 HugoBlog，进去之后初始化 Hugo Blog：hugo new site .</description></item><item><title>.gitignore 的写法</title><link>https://Jimall.github.io/tech/posts/03.gitignore/</link><pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/03.gitignore/</guid><description>在一个项目中，并不是所有的文件都需要使用 Git 进行版本管理，比如一些自动生成的文件，这时候可以在项目中添加 .gitignore 文件来忽略一些不需要进行版本管理的文件。
.gitignore 有一套语法，下面介绍一下：
.gitignore 文件语法 首先 .gitignore 文件每一行定义一条规则，从上到下进行解释的。
注释 使用 # 行注释
通配符匹配 .gitignore 可以使用通配符匹配，并且常常用到（* 用的比较多）
* 表示一个或多个字符
[] 表示范围
? 表示单个字符
忽略文件和否定忽略文件 每一行，写路径即可忽略掉相应的内容，在路径前使用 ! 即可取消忽略相应路径，比如：
# 忽略 .exe 文件 *.exe # 否定忽略 main.exe，由于文件是从上到下进行解释的，所以上下两条规则的意思是忽略除了 main.exe 的所有 .exe 文件 !main.exe # 忽略 build 文件夹 build/ 防止递归 直接制定文件名，实际上是递归的忽略，也就是说 *.exe 会忽略目录下的所有 .exe 文件。
使用 / 防止递归：
# 仅在当前目录下忽略 temp 文件， 但不包括子目录下的 subdir/temp /temp # 忽略 build/ 文件夹下的所有文件 build/ # 忽略 doc/notes.</description></item><item><title>一些有用的命令行工具</title><link>https://Jimall.github.io/tech/posts/articleshare/commandline/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/articleshare/commandline/</guid><description>看到一篇文章，介绍了一些有用的命令行工具，挺有意思的
https://zhuanlan.zhihu.com/p/373633350
个人感觉比较有用的：
httpie：sudo apt install httpie
感觉命令格式比 CUrl 友好
bat: sudo apt install bat
可以完全替代 cat
gpustat: sudo apt install gpustat
查询 GPU 状态，GPU 版本的 top
ohmyzsh:
这个自然不用多说了，就是牛</description></item><item><title>Anki 的配置</title><link>https://Jimall.github.io/tech/posts/usefultools/anki/</link><pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/usefultools/anki/</guid><description>Anki 在安装和下载上没有很大的难度，电脑端直接安装，Android 端 Google Play 直接下载。
但是在同步方面有一定的问题，因为同步使用 Ankiweb 服务，这是个国外的服务，需要挂梯子。
需要注意的事情是 PC 端直接挂梯子会发现登录报错，这个时候需要配置 HTTP_PROXY 环境变量：每次打开anki都提示发生网络错误 ? - 劳模盐的回答 - 知乎
配置完之后就能愉快的挂梯子同步了。</description></item><item><title>Leetcode-082-删除链表中的重复元素II</title><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-082-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</link><pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-082-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</guid><description>题目链接：
https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/
tag：链表 虚拟头
如果下两个节点值相等，就证明有连续相等的值，然后进行顺序遍历直到找到不相等的值作为下一个节点。
这题更加体现虚拟头的作用，可以直接开始判断，如果不使用虚拟头则感觉要分情况讨论。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; ListNode current = dummy; // 循环内的流程先画好图想清楚，基本画好图根据图写好代码，后面就是一些细节问题 while (current.</description></item><item><title>Leetcode-083-删除排序链表中的重复元素</title><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link><pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid><description>题目链接：
https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/
tag：链表
简单，不需要很多技巧，判断后面的节点是否与当前节点值相等，如果相等就删除，遍历一遍即可。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode cur = head; while (cur != null) { // 如果下一个节点与当前节点值相等，则删除 if (cur.next != null &amp;amp;&amp;amp; cur.</description></item><item><title>Kotlin Learning Snippets</title><link>https://Jimall.github.io/tech/posts/01.kotlin-learning-snippets/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/01.kotlin-learning-snippets/</guid><description>最近看到 Kotlin 可以做桌面应用甚至 Multiplatform 应用，感觉后面能用上，于是学一波！下面记录一些有意义的 Snippets。
学习材料 Idea Edu Plugin 课程 Kotlin Koan
Kotlin 官网文档
JetBrains 的社区建设做得很好，文档写的很好，把 Kotlin Koan 过一遍基本就没啥问题了。
这种看文档去解决练习的方式个人认为是最利于有一定经验的编程者上手一个技术的方法。
函数声明 fun sum(a: Int, b: Int): Int { return a + b } fun sum(a: Int = 1, b: Int = 2): Int = a + b</description></item><item><title>Leetcode-21-合并两个有序链表</title><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description>题目链接：
https://leetcode-cn.com/problems/merge-two-sorted-lists/
tag：归并排序 链表 虚拟头
链表和数组是类似的，所以合并两个有序链表可以借鉴合并两个有序数组的方法，不难想到使用归并排序的策略。
做链表题是时刻考虑判空，考虑到传入的 ListNode 可能为 null，即返回的链表可能为 null，使用虚拟头解决来避免判空。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 虚拟头 ListNode result = new ListNode(); ListNode current = result; // 以下就是归并操作 ListNode left = l1; ListNode right = l2; while (left !</description></item><item><title>LinkedList</title><link>https://Jimall.github.io/tech/posts/leetcode/topic/01.%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/topic/01.%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</guid><description>链表结构 线性结构
public class ListNode { int val; ListNode next; } 链表的基本操作 要熟悉链表的常用操作和各自复杂度。
插入操作：O(N)
删除操作：O(N)
查找操作：O(N)
要知道为什么是这样的复杂度。
解题注意事项 解题时心中要时刻默念：
先画图，再解题 时刻考虑判空 链表题只要能画出图，解题的方向基本不会出问题，容易出错的地方在判空上。
解题技巧 链表常用的解题技巧：
虚拟头 快慢指针 虚拟头 虚拟头在返回的链表头结点可能为 null 的时候可以用上，利用虚拟头可以避免对返回值判空，可以避免分类讨论，是链表题中很常见的一个技巧。
虚拟头的常见模式如下，先创建一个链表，然后将链表头和输入链表连接：
ListNode dummy = new ListNode(); // 将虚拟头和输入链表连接 dummy.next = input; 然后进行各种操作之后返回虚拟头的下一个节点，这样即使 input 全部删除了，即返回值为 null，也不用作判断。
return dummy.next; 快慢指针 快慢指针的技巧用在一些特定的题目中，是一种固定的套路。
主要用来判断链表成环：
https://leetcode-cn.com/problems/linked-list-cycle/
https://leetcode-cn.com/problems/reverse-linked-list-ii/
同时也可以利用快慢指针找到链表中点：
https://leetcode-cn.com/problems/middle-of-the-linked-list/
题目推荐 21.合并两个有序链表——题解✅Leetcode✅ 82.删除排序链表中的重复元素II——题解✅Leetcode✅ 83.删除排序链表中的重复元素——题解✅Leetcode✅ 86.分隔链表——题解✅Leetcode✅ 92.反转链表 II——题解✅Leetcode✅ 138.复制带随机指针的链表——题解Leetcode 141.</description></item><item><title/><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</link><pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</guid><description>题目链接：
https://leetcode-cn.com/problems/reorder-list/
tag：链表
这题难度本身不大，但是涉及很多技巧，一方面是使用快慢指针寻找链表中点，一方面是反转链表，然后就是链表合并。
找到链表中点，反转后半部分的链表然后进行链表合并即可。
找链表中点可以使用快慢指针的方法，有一道 Leetcode 题：
https://leetcode-cn.com/problems/middle-of-the-linked-list/
注意找链表中点有讲究：
如果条件为 fast != null &amp;amp;&amp;amp; fast.next != null，那么偶数长度的链表中点为中间两个的第二个，如果条件为 fast.next != null &amp;amp;&amp;amp; fast.next.next != null，那么偶数长度的链表中点为中间两个的第一个。
那么代码如下：
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public void reorderList(ListNode head) { if (head == null) { return; } ListNode mid = findMiddle(head); ListNode head2 = mid.</description></item><item><title>Leetcode-141-环形链表</title><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link><pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid><description>题目链接：
https://leetcode-cn.com/problems/linked-list-cycle/
tag：链表 快慢指针
使用快慢指针判断链表成环一个很常见的技巧，原理就是速度快的人在没成环的时候一定不可能被速度慢的人追上。需要注意的是，比较是否相等的时候，比较的是 node 是否相等，而不是 val 是否相等。
注意，让两个指针初始值为 head，因为另一种形式的环形链表题一定要两个指针从 head 开始走，防止搞混所以这样操作。
/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode slow = head; ListNode fast = head; while (slow !</description></item><item><title>Leetcode-142-环形链表II</title><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link><pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid><description>题目链接：
https://leetcode-cn.com/problems/linked-list-cycle-ii/
tag：链表 快慢指针
判断链表成环我们已经会了，找到环形链表的开始节点需要通过数学推导发现规律得到：
所以代码如下，值得注意的是 slow 和 fast 的开始节点一定要为 head，不然这种直接使用方法不成立：
/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { if (head == null) { return null; } ListNode slow = head; ListNode fast = head; // 可以简化掉 slow !</description></item><item><title/><link>https://Jimall.github.io/diary/miserable_faith%E7%97%9B%E4%BB%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/diary/miserable_faith%E7%97%9B%E4%BB%B0/</guid><description>MISERABLE FAITH 痛仰</description></item><item><title/><link>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/leetcode/problem/leetcode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description/></item></channel></rss>