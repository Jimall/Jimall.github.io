<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BLOG</title><link>https://Jimall.github.io/technology/</link><description>Recent content on BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 03 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://Jimall.github.io/technology/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring IoC 组件详解</title><link>https://Jimall.github.io/technology/posts/java/spring/ioc/spring%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/java/spring/ioc/spring%E7%AC%94%E8%AE%B0/</guid><description>&lt;p>Spring 有两大核心机制：&lt;/p>
&lt;ol>
&lt;li>IoC (Inverse of Control, 控制反转)&lt;/li>
&lt;li>AOP (Aspect-Oriented Programming, 面向切面编程)&lt;/li>
&lt;/ol>
&lt;p>学习 Spring 的核心（单指 Spring 本身，不包括别的组件）就在于学习理解这两大核心机制。&lt;/p>
&lt;p>这篇文章我们来讲讲 IoC。&lt;/p>
&lt;h2 id="ioc">IoC&lt;/h2>
&lt;p>IoC 是 Spring 的核心机制。&lt;/p>
&lt;h3 id="什么是-ioc">什么是 IoC？&lt;/h3>
&lt;p>IoC (Inversion of Control)，即“控制反转”。它不是一种技术，而是一种设计思想。在 Java 开发中，IoC 意味着将你设计好的对象交给容器控制，而不是在你的对象内部控制（控制的意思是说对象内部需要通过 new 等方式创建依赖对象，需要我们自己进行创建）。&lt;/p>
&lt;p>如何理解好 IoC 呢？理解好 Ioc 的关键是要明确”谁控制谁？控制什么？为何是反转？哪些方面反转了？”：&lt;/p>
&lt;p>”谁控制谁？控制什么？“：在传统 Java SE 程序设计中，我们直接在对象内部通过 new 创建对象，是对象主动去创建依赖对象，而 &lt;strong>IoC 通过一个专门的容器（称为 IoC 容器）来创建这些对象&lt;/strong>；谁控制谁？&lt;strong>IoC 容器控制了对象&lt;/strong>；控制什么？&lt;strong>控制了外部资源获取&lt;/strong>（不只是对象包括比如文件等）。&lt;/p>
&lt;p>“为何是反转？哪些方面反转了？”：有反转就有正转，传统应用程序由我们自己在程序中主动控制去获取依赖对象，也就是正转，而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？&lt;strong>因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转&lt;/strong>；哪些方面反转了？&lt;strong>依赖对象的获取反转&lt;/strong>。&lt;/p>
&lt;p>所以控制反转的意思就是，&lt;strong>IoC 容器控制对象，让依赖对象的获取反转&lt;/strong>。&lt;/p>
&lt;h3 id="ioc-能做什么">IoC 能做什么？&lt;/h3>
&lt;p>IoC 不是一种技术，而是一种设计思想，一个重要的面向对象编程的法则，&lt;strong>它能指导我们如何设计出松耦合、更优良的程序&lt;/strong>。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试。有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。&lt;/p>
&lt;p>IoC 很好的体现了面向对象设计法则中的好莱坞法则：“别找我们，我们找你”，即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。&lt;/p>
&lt;h3 id="di">DI&lt;/h3>
&lt;p>DI (Dependency Injection) 依赖注入。这也是 Spring 中的一个重要概念。&lt;/p>
&lt;p>依赖注入：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。&lt;/p>
&lt;p>理解 DI 的关键是：“谁依赖谁？为什么需要依赖？谁注入谁？注入了什么？”：&lt;/p>
&lt;p>”谁依赖于谁？“：&lt;strong>应用程序依赖于 IoC 容器&lt;/strong>&lt;/p>
&lt;p>”为什么需要依赖？“：&lt;strong>应用程序需要 IoC 容器来提供对象需要的外部资源&lt;/strong>&lt;/p>
&lt;p>“谁注入谁？”：&lt;strong>IoC 容器注入应用程序某个对象，应用程序依赖的对象&lt;/strong>&lt;/p>
&lt;p>”注入了什么？“：&lt;strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）&lt;/strong>&lt;/p>
&lt;p>&lt;strong>IoC 和 DI 有什么关系呢？其实它们是同一个概念的不同角度描述&lt;/strong>，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。&lt;/p>
&lt;h3 id="ioc-demo-和详细使用">IoC Demo 和详细使用&lt;/h3>
&lt;p>demo 放在代码里面，这样可以结合代码进行理解&lt;/p>
&lt;h3 id="参考">参考&lt;/h3>
&lt;p>IoC 部分，参考：&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/GoGleTech/article/details/79557416">https://blog.csdn.net/GoGleTech/article/details/79557416&lt;/a>&lt;/p>
&lt;h2 id="ioc-底层原理">IoC 底层原理&lt;/h2></description></item><item><title>Spring结合Junit进行单元测试</title><link>https://Jimall.github.io/technology/posts/java/spring/spring%E7%BB%93%E5%90%88junit%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/java/spring/spring%E7%BB%93%E5%90%88junit%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>&lt;p>由于 Spring 各种注解的使用需要结合 xml 配置文件，所以单元测试没有办法直接写，需要引入 Spring 对单元测试的支持。下面讲讲详细步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>引入 Spring-test 和 junit test 依赖：&lt;/p>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;4.13&amp;lt;/version&amp;gt;
&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;5.2.9.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>在测试类中添加 @RunWith 和 @ContextConfiguration 注解&lt;/p>
&lt;pre>&lt;code class="language-Java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&amp;quot;classpath:spring.xml&amp;quot;)
public class StudentTest {
@Autowired
public Student student;
@Test
public void testStudentCreation() {
System.out.println(student);
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;p>这样就可以正常使用了，需要注意的是，spring.xml 中需要配置才能使用 @Autowired 等注解：&lt;/p>
&lt;pre>&lt;code class="language-xml"> &amp;lt;context:component-scan base-package=&amp;quot;org.example&amp;quot;/&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>（同时 xml 文件头还需要引入 context 相关的域，alt+enter 即可）&lt;/p></description></item><item><title>Java 集合框架 Map 接口</title><link>https://Jimall.github.io/technology/posts/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/map%E6%8E%A5%E5%8F%A3/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/map%E6%8E%A5%E5%8F%A3/</guid><description>&lt;p>图示：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/SUSTechee/images/blog/20210310083541.png" alt="">&lt;/p>
&lt;p>Map 通过 key-value 形式存元素，每个元素称为 entry，即一个 entry 包含 key 和 value 两个值。&lt;/p>
&lt;h2 id="map-接口-api">Map 接口 api&lt;/h2>
&lt;p>信息：isEmpty(), size()&lt;/p>
&lt;p>添加修改：put(key, value) 如果 key 存在就会修改，否则添加&lt;/p>
&lt;p>查找：containKey(), containValue()&lt;/p>
&lt;p>遍历：entrySet() 返回映射关系的 set 视图，keySet() 返回 key 的 set 视图，values() 返回 value 的 collection 视图&lt;/p>
&lt;p>删除：remove(key)，clear()&lt;/p>
&lt;h2 id="常用集合">常用集合&lt;/h2>
&lt;h3 id="hashmap">HashMap&lt;/h3>
&lt;p>了解 HashMap，首先需要了解哈希算法：&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/higerMan/p/11907117.html">哈希冲突及四种解决方法&lt;/a>&lt;/p>
&lt;p>四种解决方法：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>开放地址法
1.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拉链法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>建立公共溢出区&lt;/p>
&lt;p>建立公共溢出区存储所有哈希冲突的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>再哈希法&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>然后需要了解红黑树：&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/v_JULY_v/article/details/6105630">红黑树介绍和实现&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>红黑树是平衡的二叉查找树，和 AVL tree 是类似的，不同的是 AVL tree 和红黑树维持平衡的规则不太一样。&lt;/li>
&lt;li>红黑树的关键性质：
&lt;ul>
&lt;li>每个结点要么是红的要么是黑的。&lt;/li>
&lt;li>根结点是黑的。&lt;/li>
&lt;li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。&lt;/li>
&lt;li>如果一个结点是红的，那么它的两个儿子都是黑的。&lt;/li>
&lt;li>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>理解红黑树的关键是理解平衡和理解二叉查找树，二叉查找树插入、删除和查找的开销都是 O(h)，由于红黑树平衡，那么 h 最大为 log(n)，所以红黑树插入、删除和查找的开销为 log(n)&lt;/li>
&lt;/ul>
&lt;p>开始看 HashMap 解析博文，根据博文再看 HashMap 源码进行理解：&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/38615394">HashMap 结构详解&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/127147909">HashMap 详解&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/127147909">HashMap 原理详解（面试题）&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>HashMap 的底层是数组、链表和红黑树&lt;/li>
&lt;li>数组是用于进行映射的，hashCode 之后就可以直接存在数组上，然后就可以 O(1) 查找，同时数组长度不够的时候带有扩容机制 resize，但是注意 resize 是很耗性能的&lt;/li>
&lt;li>hashCode 之后会产生 hash 碰撞，这样在数组上的同一位置会有多个结果，所以用链表串起来，在查找的时候再搜一遍链表即可&lt;/li>
&lt;li>链表的搜索复杂度为 O(n)，这样链表太长的情况下会很慢，这个时候，把链表想象成极端情况下的二叉树，就不难想到把链表平衡树化，采取的操作是构建为红黑树，这样平衡之后就可以 O(logn) 搜索&lt;/li>
&lt;li>HashMap 线程不安全&lt;/li>
&lt;/ul>
&lt;h3 id="linkedhashmap">LinkedHashMap&lt;/h3>
&lt;p>LinkedHashMap 和 HashMap 几乎一样，事实上，LinkedHashMap 继承自 HashMap 唯一的不同在于遍历顺序上：&lt;/p>
&lt;p>&lt;a href="https://sunweiguo.github.io/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/">LinkedHashMap 和 HashMap 比较&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>&lt;code>HashMap&lt;/code>的输出顺序与元素的输入顺序无关，因为遍历的时候它自己根据读取方便来确定散列值取数据，&lt;code>LinkedHashMap&lt;/code>可以按照输入顺序输出，也可以根据读取元素的顺序输出&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.jianshu.com/p/181df0893158">LinkedHashMap 详解&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>LinkedHashMap 维护了一个 LinkedHashMapEntry 双向链表，在遍历的时候 iterator 在 LinkedHashMapEntry 上遍历。&lt;/li>
&lt;/ul>
&lt;h3 id="treemap">TreeMap&lt;/h3>
&lt;p>&lt;a href="https://www.jianshu.com/p/d9ad7f6d75a0">TreeMap 详解&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>TreeMap 就是一棵红黑树，有可以排序的特性&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.csdn.net/xlgen157387/article/details/47907721#:~:text=HashMap%E5%92%8CTreeMap%E6%AF%94%E8%BE%83,Map%E6%97%B6%E5%80%99%E6%89%8D%E7%94%A8TreeMap.">TreeMap 和 HashMap 的比较&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>HashMap:适用于在Map中插入、删除和定位元素。&lt;/li>
&lt;li>Treemap:适用于按自然顺序或自定义顺序遍历键（key）。&lt;/li>
&lt;li>HashMap通常比TreeMap快一点（树和哈希表的数据结构使然），建议多使用HashMap,在需要排序的Map时候才用TreeMap.&lt;/li>
&lt;li>HashMap 非线程安全 TreeMap 非线程安全&lt;/li>
&lt;li>HashMap的结果是没有排序的，而TreeMap输出的结果是排好序的。&lt;/li>
&lt;/ul>
&lt;h3 id="concurrenthashmap">ConcurrentHashMap&lt;/h3>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/40327960">ConcurrentHashMap 和 HashMap 的对比&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。&lt;/li>
&lt;/ul>
&lt;h3 id="hashtable">Hashtable&lt;/h3>
&lt;p>Hashtable 和 HashMap 实现很类似，但是有一定的不同：&lt;/p>
&lt;p>&lt;strong>1.实现&lt;/strong>：HashMap继承的类是AbstractMap类，而Hashtable继承的是Dictionary类，而Dictionary是一个过时的类，因此通常情况下建议使用HashMap而不是使用Hashtable&lt;/p>
&lt;p>&lt;strong>2.内部结构&lt;/strong>：其实HashMap与Hashtable内部基本都是使用&lt;strong>数组-链表&lt;/strong>的结构，但是HashMap引入了红黑树的实现，内部相对来说更加复杂而性能相对来说应该更好&lt;/p>
&lt;p>&lt;strong>3.NULL值控制&lt;/strong>：通过前面的介绍我们知道Hashtable是不允许key-value为null值的，Hashtable对于key-value为空的情况下将抛出NullPointerException，而HashMap则是允许key-value为null的，HashMap会将key=null方法index=0的位置。&lt;/p>
&lt;p>&lt;strong>4.线程安全&lt;/strong>：通过阅读源码可以发现Hashtable的方法中基本上都是有synchronized关键字修饰的，但是HashMap是线程不安全的，故对于单线程的情况下来说HashMap的性能更优于Hashtable，单线程场景下建议使用HashMap.&lt;/p>
&lt;p>在源码里面经常出现 transient 关键字：&lt;a href="https://www.cnblogs.com/lanxuezaipiao/p/3369962.html">transient 关键字&lt;/a>，总结来说就是：为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中&lt;/p></description></item><item><title>Leetcode-086-分隔链表</title><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</guid><description>&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/partition-list/">https://leetcode-cn.com/problems/partition-list/&lt;/a>&lt;/p>
&lt;p>tag：链表 虚拟头&lt;/p>
&lt;p>关键是构造小大两个链表，然后串起来。只要想到这个思路，代码实现就很简单了。&lt;/p>
&lt;p>注意串的时候，需要将大链表的尾部设为 null，不然会成环。&lt;/p>
&lt;pre>&lt;code class="language-Java">/**
* Definition for singly-linked list.
* public class ListNode {
* int val;
* ListNode next;
* ListNode() {}
* ListNode(int val) { this.val = val; }
* ListNode(int val, ListNode next) { this.val = val; this.next = next; }
* }
*/
class Solution {
public ListNode partition(ListNode head, int x) {
ListNode current = head;
ListNode dummySmall = new ListNode();
ListNode currentSmall = dummySmall;
ListNode dummyLarge = new ListNode();
ListNode currentLarge = dummyLarge;
while (current != null) {
if (current.val &amp;lt; x) {
currentSmall.next = current;
currentSmall = currentSmall.next;
} else {
currentLarge.next = current;
currentLarge = currentLarge.next;
}
current = current.next;
}
// 这一步很关键，不然会成环
currentLarge.next = null;
currentSmall.next = dummyLarge.next;
return dummySmall.next;
}
}
&lt;/code>&lt;/pre></description></item><item><title>Leetcode-092-反转链表II</title><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</guid><description>&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">https://leetcode-cn.com/problems/reverse-linked-list-ii/&lt;/a>&lt;/p>
&lt;p>tag：链表&lt;/p>
&lt;p>在串中，部分反转可以通过先部分反转，再整体反转的思路来进行。链表部分反转也是一样的，不过&lt;strong>链表部分反转之后通过穿针引线的方式串回原链表即可&lt;/strong>，不需要进行反转。&lt;/p>
&lt;p>具体实现就是，首先切割出子链表，然后反转子链表，最后串起来。切割子链表这里的操作需要注意、&lt;/p>
&lt;pre>&lt;code class="language-Java">/**
* Definition for singly-linked list.
* public class ListNode {
* int val;
* ListNode next;
* ListNode() {}
* ListNode(int val) { this.val = val; }
* ListNode(int val, ListNode next) { this.val = val; this.next = next; }
* }
*/
class Solution {
public ListNode reverseBetween(ListNode head, int left, int right) {
// 虚拟头
ListNode dummy = new ListNode();
dummy.next = head;
ListNode leftNode = dummy;
// 获得左节点右节点和边界节点
for (int i = 0; i &amp;lt; left - 1; i++) {
leftNode = leftNode.next;
}
ListNode leftEdge = leftNode;
leftNode = leftNode.next;
ListNode rightNode = leftNode;
for (int i = 0; i &amp;lt; right - left; i++) {
rightNode = rightNode.next;
}
ListNode rightEdge = rightNode.next;
// 分割子链表
// leftEdge.next = null; // 要不要这一步都行
rightNode.next = null;
// 反转子链表
reverse(leftNode);
// 串起来
leftNode.next = rightEdge;
leftEdge.next = rightNode;
return dummy.next;
}
public void reverse(ListNode node) {
ListNode prev = null;
ListNode current = node;
while (current != null) {
ListNode next = current.next;
current.next = prev;
prev = current;
current = next;
}
}
}
&lt;/code>&lt;/pre></description></item><item><title>Leetcode-206-反转链表</title><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/&lt;/a>&lt;/p>
&lt;p>tag：链表&lt;/p>
&lt;p>链表反转的关键在于记录前驱节点 prev，想到这点就很快能做出来。&lt;/p>
&lt;pre>&lt;code class="language-Java">/**
* Definition for singly-linked list.
* public class ListNode {
* int val;
* ListNode next;
* ListNode() {}
* ListNode(int val) { this.val = val; }
* ListNode(int val, ListNode next) { this.val = val; this.next = next; }
* }
*/
class Solution {
public ListNode reverseList(ListNode head) {
ListNode prev = null;
ListNode current = head;
while (current != null) {
ListNode next = current.next;
current.next = prev;
prev = current;
current = next;
}
return prev;
}
}
&lt;/code>&lt;/pre>
&lt;p>需要注意，有的时候会要求递归实现：&lt;/p></description></item><item><title>TypeScript 简明教程</title><link>https://Jimall.github.io/technology/posts/frontend/typescript/typescript-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/frontend/typescript/typescript-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</guid><description>&lt;p>TypeScript 是 JavaScript 的超集，能够用类似写 Java 的体验（更准确说来更像 Kotlin）来写 JavaScript，很方便很快捷。&lt;/p>
&lt;h2 id="typescript-类型">TypeScript 类型&lt;/h2>
&lt;p>TypeScript 的数据类型分为 boolean, number, string, array, tuple, enum, object, null, undefined, any, void, never&lt;/p>
&lt;ol>
&lt;li>
&lt;p>布尔（boolean）类型&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let flag: boolean = false
&lt;/code>&lt;/pre>
&lt;p>有 true 和 false 两个值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数字（number）类型&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let num1: number = 1
let num2: number = 1.8
let num3: number = -1
&lt;/code>&lt;/pre>
&lt;p>各种数字都是 number 类型，并且支持二进制八进制和十六进制值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字符串（string）类型&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let name: string = &amp;quot;typescript&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>支持模板字符串，用反引号&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let description: string = `${name} is good`
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>数组（array）类型&lt;/p>
&lt;p>和 JavaScript 数组一样，类似于 Python 里的链表&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let list: number[] = [1, 2, 3]
let list: Array&amp;lt;number&amp;gt; = [1, 2, 3]
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>元组（tuple）类型&lt;/p>
&lt;p>元组中可以存不同类型的值&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let x: [string, number] = [&amp;quot;hello&amp;quot;, 10]
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>枚举（enum）类型&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">enum Color {
Red,
Green,
Blue
}
const c: Color = Color.Green
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>对象（object）类型&lt;/p>
&lt;p>表示非原始类型，即除了 number、string、boolean，null，undefined 之外的类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>null 和 undefined 类型&lt;/p>
&lt;p>类型本身作用不是很大，但是 null 和 undefined 类型是所有类型的子类型，所以任何变量的值都可以是 null 或者 undefined。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>any 类型&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">const list: any[] = [1, true, &amp;quot;string&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>表示任意一个类型，当编译阶段不清楚类型的时候可以指定为 any 类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>void 类型&lt;/p>
&lt;p>表示没有任何类型，没有返回值的函数为 void 类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>never 类型&lt;/p>
&lt;p>never 表示用不存在的类型，总是会抛出异常或根本不会有返回值的函数表达式或箭头表达式的返回值类型可以为 never 类型。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="typescript-接口">TypeScript 接口&lt;/h2>
&lt;p>TypeScript 接口和 Java 稍有不同，它更多是定义对象的结构，比如指定有什么元素、有什么方法之类的。&lt;/p>
&lt;p>语法如下：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">interface Information {
username: string
}
// 如不符合 Information 接口定义，编译阶段报错
let infor: Information = {
username: &amp;quot;Zhang San&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>接口中的属性默认情况下是必须的，不然编译阶段会报错，可以使用 &lt;code>?&lt;/code> 定义可选属性：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">interface Information {
username: string
nickName?: string
}
// nickName 为可选属性，符合接口标准
let infor: Information = {
username: &amp;quot;Zhang San&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>同时一些对象属性可以指定为只读，这样后续不能被修改值，这就类似于常量使用 const 声明，接口中的常量使用 readonly 声明：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">interface Information {
username: string
nickName?: string
readonly id: string
}
let infor: Information = {
username: &amp;quot;Zhang San&amp;quot;
id: &amp;quot;123456&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;h2 id="函数">函数&lt;/h2>
&lt;pre>&lt;code class="language-TypeScript">function add(a: number, b: number): number {
return a + b
}
&lt;/code>&lt;/pre>
&lt;p>函数可以使用 &lt;code>?&lt;/code> 指定可选参数：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">function buildName(firstName: string, lastName?: string): string {
if (lastName) {
return `${firstName} ${lastName}`
} else {
return firstName
}
}
&lt;/code>&lt;/pre>
&lt;p>函数可以指定默认参数，默认参数本身就是可选的，不需要指定 &lt;code>?&lt;/code>：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">function buildName(firstName: string, lastName?: string): string {
if (lastName) {
return `${firstName} ${lastName}`
} else {
return firstName
}
}
&lt;/code>&lt;/pre>
&lt;p>可以指定剩余参数：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">function sum(x: number, y: number, ...rest: number[]) {
return x + y + reduce((acc, value) =&amp;gt; acc + value, 0);
}
&lt;/code>&lt;/pre>
&lt;h2 id="typescript-类">TypeScript 类&lt;/h2>
&lt;pre>&lt;code class="language-TypeScript">class Circle {
private radius: number
private x: number
private y: number
readonly PI: number = 3.14
get radius(): number {
return this.number
}
get x(): number {
return this.x
}
set x(x: number) {
this.x = x
}
get y(): number {
return this.y
}
set y(y: number) {
this.y = y
}
constructor(radius: number = 1, x: number = 1, y: number = 1) {
this.radius = radius
this.x = x
this.y = y
}
getArea(): number {
return PI * radius * radius
}
}
&lt;/code>&lt;/pre>
&lt;p>默认为 public，同时也支持 private 和 protected，和 Java 写法极其类似，不过 getter 和 setter 的写法和构造器的写法有所不同。&lt;/p>
&lt;p>同时类还可以有静态属性：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">class Constants {
static PI: number = 3.14
}
&lt;/code>&lt;/pre>
&lt;p>使用 extends 关键字继承类，使用 implements 关键字实现接口，写法和 Java 类似，包括也有 super 关键字，不多赘述：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">class Person {
protected name: string;
constructor(name: string) {
this.name = name;
}
}
class Employee extends Person {
private department: string;
constructor(name: string, department: string) {
super(name);
this.department = department;
}
public getElevatorPitch() {
return `Hello, my name is ${this.name} and I work in ${this.department}.`;
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="typescript-类型推论">TypeScript 类型推论&lt;/h2>
&lt;p>对于未显式指定的类型的变量，TypeScript 会进行类型推断，所有的变量一定有其类型&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let x: number = 0;
x = 1; // OK
x = '1'; // error
&lt;/code>&lt;/pre>
&lt;h2 id="typescript-类型断言">TypeScript 类型断言&lt;/h2>
&lt;p>可以通过类型断言来告诉编译器 any 是哪种类型，类型断言有两种形式：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>尖括号&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let someVal: any = &amp;quot;a string&amp;quot;
let strLength: number = (&amp;lt;string&amp;gt;someVal).length
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>as 语法&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let someVal: any = &amp;quot;a string&amp;quot;
let strLength: number = (someVal as string).length
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;p>两种形式是等价的。至于使用哪个大多数情况下是凭个人喜好；然而，当在 TypeScript 里使用到 JSX 时，只有 as 形式的断言是被允许的。&lt;/p>
&lt;h2 id="typescript-非空断言关键字">TypeScript 非空断言关键字&lt;/h2>
&lt;p>使用 ！来指定非空的变量，即告诉编译器值不能为 null。&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let a: number | undefined = undefined
let b: number = a!
&lt;/code>&lt;/pre>
&lt;h2 id="typescript-泛型">TypeScript 泛型&lt;/h2>
&lt;p>TypeScript 泛型写法和 Java 泛型相似：&lt;/p>
&lt;p>泛型方法：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">function add&amp;lt;T&amp;gt;(a: T, b: T): T {
return a + b
}
&lt;/code>&lt;/pre>
&lt;p>泛型接口：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">interface GenericIdentityFn&amp;lt;T&amp;gt; {
(arg: T): T;
}
function identity&amp;lt;T&amp;gt;(arg: T): T {
return arg;
}
let myIdentity: GenericIdentityFn&amp;lt;number&amp;gt; = identity;
&lt;/code>&lt;/pre>
&lt;p>泛型类：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">class GenericNumber&amp;lt;T&amp;gt; {
zeroValue: T;
add: (x: T, y: T) =&amp;gt; T;
}
&lt;/code>&lt;/pre>
&lt;p>泛型约束：&lt;/p>
&lt;p>可以使用 extends 语法来约束泛型：&lt;code>&amp;lt;T extends Lengthwise&amp;gt;&lt;/code>$&lt;/p>
&lt;p>泛型参数默认值：&lt;/p>
&lt;p>泛型参数可以指定默认值：&lt;code>&amp;lt;T = number&amp;gt;&lt;/code>&lt;/p>
&lt;h2 id="联合类型">联合类型&lt;/h2>
&lt;p>使用 &lt;code>|&lt;/code> 表示联合类型，类似 C 语言中的 union，可以表示多种类型中的一个：&lt;/p>
&lt;pre>&lt;code class="language-TypeScript">let item: string | number | undefined
&lt;/code>&lt;/pre>
&lt;p>那么 item 可以是三种类型中的任意一种类型&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>语言更多特性参考官网文档：&lt;/p>
&lt;p>&lt;a href="https://www.typescriptlang.org/docs/handbook/intro.html">https://www.typescriptlang.org/docs/handbook/intro.html&lt;/a>&lt;/p>
&lt;p>本文参考：&lt;/p>
&lt;p>&lt;a href="https://sinoui.github.io/sinoui-guide/docs/ts-tutorial#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC">https://sinoui.github.io/sinoui-guide/docs/ts-tutorial#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC&lt;/a>（讲的很全，不过有些地方讲的多了）&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/twypx/article/details/80290806">https://blog.csdn.net/twypx/article/details/80290806&lt;/a>（有些地方没讲全）&lt;/p></description></item><item><title>加密算法</title><link>https://Jimall.github.io/technology/posts/06.encryption/</link><pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/06.encryption/</guid><description>&lt;p>加密算法涉及一些概念：数字签名、数据加密解密、加密算法、对称加密算法、非对称加密算法、单向加密算法。下面进行介绍。&lt;/p>
&lt;h2 id="加密和解密">加密和解密&lt;/h2>
&lt;p>加密和解密主要是为了&lt;strong>防止传输过程中的数据泄露&lt;/strong>，因为传输过程中不免会被抓包什么的。&lt;/p>
&lt;p>数据加密的基本过程，就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为密文。这样，发送的过程中，不会被非法人窃取，因为别人看不懂加密后的东西是啥。&lt;/p>
&lt;p>加密的逆过程为解密，即将”密文“转化为其原来数据的过程，因为传输后需要使用数据，不可能用加密后的看不懂的密文。&lt;/p>
&lt;h2 id="加密算法及应用">加密算法及应用&lt;/h2>
&lt;p>加密算法分为对称加密算法、非对称加密算法、单向加密算法。&lt;/p>
&lt;h3 id="对称加密算法">对称加密算法&lt;/h3>
&lt;p>&lt;strong>对称加密算法&lt;/strong>是应用较早的加密算法，又称为共享密钥加密算法。在对称加密算法中，&lt;strong>使用的密钥只有一个&lt;/strong>，发送和接收双方都使用这个密钥对数据进行加密和解密。这就要求加密和解密方事先都必须知道加密的密钥。&lt;/p>
&lt;p>&lt;strong>数据加密过程&lt;/strong>：在对称加密算法中，数据发送方将明文（原始数据）和加密密钥一起经过特殊加密处理，生成复杂的加密密文进行发送。&lt;/p>
&lt;p>&lt;strong>数据解密过程&lt;/strong>：数据接收方收到密文后，若想读取原数据，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。&lt;/p>
&lt;p>这个道理可以这样理解：我们写 markdown，规则定好了，比如 # 表示一级标题（相当于秘钥），所以我这边就这样写一级标题（加密），然后发给你，因为采用一样的规则，你也解读成一级标题（解密），这样信息在两边就相同了。有人看到了我写的东西（密文），但是他不知道这个规则，他就不知道我写的东西究竟是啥。&lt;/p>
&lt;p>&lt;strong>对称加密算法的优缺点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>优点：操作比较简单，加密速度快，秘钥简单。经常在消息发送方需要加密大量数据时使用。&lt;/li>
&lt;li>缺点：秘钥存在传输泄露风险。因为新增一个协作方的时候，它需要秘钥来进行加密和解密，所以我们要把秘钥发给对方，那么这个过程中秘钥如果泄露，无论谁给我们发消息，获取秘钥的人都可以用这个秘钥去解密，相当于没有加密发消息（类似于抗战时期我方的密码本被敌方截获了，那敌方肯定啥都知道了）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>常用对称加密算法&lt;/strong>：DES，3DES，AES 等。在 jdk 中都有封装。&lt;/p>
&lt;h3 id="非对称加密算法">非对称加密算法&lt;/h3>
&lt;p>&lt;strong>非对称加密算法&lt;/strong>，又称为公开密钥加密算法，顾名思义就是加密与解密的过程不是对称的，不使用同一个秘钥。它需要两个密钥，一个称为&lt;strong>公开密钥 (public key)&lt;/strong>，即公钥，另一个称为&lt;strong>私有密钥 (private key)&lt;/strong>，即私钥。公钥和私钥是结对的，生成的时候会生成一对公私钥对。&lt;/p>
&lt;p>&lt;strong>这种算法的特点&lt;/strong>是：&lt;/p>
&lt;ol>
&lt;li>使用公钥对数据进行加密，只有用对应的私钥才能进行解密。&lt;/li>
&lt;li>使用私钥对数据进行加密，只有用对应的公钥才能进行解密。&lt;/li>
&lt;/ol>
&lt;p>这里的关键点在于，&lt;strong>公钥加密的消息只能私钥解密&lt;/strong>。使用时由接收方生成公私钥对，然后将公钥传给发送方，私钥保存在服务器上，不进行任何传输，这样就不会泄露（除非有内鬼）。这种情况下，和对称加密不同，公钥可以随意分发给发送方，甚至泄漏到网上也没事，一个黑客拿着公钥没有办法解读别人发给我们的信息，所以&lt;strong>秘钥的传输是安全的，不用担心泄露，解决了对称传输中秘钥传输泄露的问题&lt;/strong>。&lt;/p>
&lt;p>非对称算法的缺点在于运算速度较慢。&lt;/p>
&lt;p>常用的非对称加密算法有：RSA、DSA、ECC 等。&lt;/p>
&lt;h3 id="单向加密算法">单向加密算法&lt;/h3>
&lt;p>&lt;strong>单向加密算法&lt;/strong>又称为不可逆加密算法，实际上就是哈希算法。它只能对明文数据进行加密，而不能对加密了的密文数据再解密成原来的明文数据，所以称为单向加密。&lt;/p>
&lt;p>单向加密的特点也就是哈希算法的特点：&lt;/p>
&lt;ol>
&lt;li>任意两段明文数据，加密以后的密文数据一定是不相同的&lt;/li>
&lt;li>任意一段明文数据，经过加密以后，其密文数据永远是相同的&lt;/li>
&lt;/ol>
&lt;p>单向加密的关键在于其应用：&lt;/p>
&lt;ol>
&lt;li>当用户注册一个新的账号时，其用户密码信息不是直接保存到数据库，而是经过单向加密后再保存，这样，即使这些账号信息被泄露，别人也不能得到相应的用户密码，因为单向加密没有办法进行解密，当然也就达不到盗窃账号的目的。&lt;/li>
&lt;li>用户 Login 的时候，系统对用户输入的密码进行单向加密，然后再去和系统中保存的加密值进行比较，但系统中并没有存明文密码，所以我们不会知道密码是什么。&lt;/li>
&lt;li>由于一样的文件，产生加密值是相同的，所以可以进行文件完整性检测。&lt;/li>
&lt;/ol>
&lt;p>常用的单向加密算法有 MD5、SHA&lt;/p>
&lt;p>提到单向加密算法经常会提到 BASE64 编码。目前 BASE64 已经成为网络上常见的传输 8Bit 字节代码的编码方式之一。&lt;/p>
&lt;p>在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64 的出现就是为了解决此问题，它是基于 64 个可打印的字符来表示二进制的数据的一种方法。&lt;/p>
&lt;p>电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此 Base64 就登场了。随之，Base64 在 URL、Cookie、网页传输少量二进制文件中也有相应的使用。&lt;/p>
&lt;h3 id="各个加密算法比较">各个加密算法比较&lt;/h3>
&lt;h2 id="数字签名数字证书和-https">数字签名、数字证书和 HTTPS&lt;/h2>
&lt;h2 id="参考阅读">参考阅读&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://juejin.cn/post/6844903638117122056">浅谈常见的七种加密算法及实现&lt;/a>：了解加密算法相关的大致框架，各个知识点解释的没那么清楚&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/54chensongxia/p/11671917.html">加解密算法最详解&lt;/a>：了解各种加密算法&lt;/li>
&lt;li>&lt;a href="https://nieyong.github.io/wiki_ny/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%B8%B8%E8%AF%86.html">加密算法常识&lt;/a>：单向加密的应用写的很好&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/wo541075754/article/details/81734770">一篇文章彻底弄懂 BASE64 编码原理&lt;/a>：关于 BASE64 编码&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？&lt;/a>：数字签名、数字证书和 https 极为通俗的解释，阮一峰永远的神，推荐阅读✅&lt;/li>
&lt;/ol></description></item><item><title>git submodule 的使用</title><link>https://Jimall.github.io/technology/posts/05.gitsubmodule/</link><pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/05.gitsubmodule/</guid><description>&lt;p>在 Git 项目中，需要包含别的 Git 项目，我们希望能够独立的使用这两个项目。比如我们的博客是一个 Git 项目，而我们需要在博客中包含别人的项目作为博客主题，我们希望能够在自己写博文后 push 不影响博客主题仓库，同时希望能够独立使用主题仓库，这样我们就可以获取最新的主题。&lt;/p>
&lt;p>这个时候需要用到 git submodule。在使用 submodule 之后，两个项目便相对独立（或者多个 submodule，那么就是多个项目相对独立）。下面介绍子模块常用的用法：&lt;/p>
&lt;h2 id="使用子模块">使用子模块&lt;/h2>
&lt;h3 id="添加子模块">添加子模块&lt;/h3>
&lt;p>在 Git 项目中包含别的 Git 项目，不能够直接到相应文件夹 clone，而需要使用 &lt;code>git add submodule&lt;/code> 命令，可以将这个命令视为子模块版本的 &lt;code>git clone&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-bash">git add submodule git@github.com/example/example.git submodule
&lt;/code>&lt;/pre>
&lt;p>上面的命令将项目克隆到 submodule 目录。会发现根目录生成了一个 .gitmodule 文件，这个文件用于保存子模块信息。&lt;/p>
&lt;h3 id="查看子模块">查看子模块&lt;/h3>
&lt;p>使用 &lt;code>git submodule&lt;/code> 命令查看当前项目的子模块。&lt;/p>
&lt;h3 id="更新子模块">更新子模块&lt;/h3>
&lt;p>在项目中使用 &lt;code>git update&lt;/code> 父模块并不会更新子模块。（别的操作同理，我们在项目中使用的各种以前使用的 git 操作都只会对父模块产生作用）&lt;/p>
&lt;p>使用 &lt;code>git submodule add&lt;/code> 添加子项目。&lt;/p>
&lt;h3 id="操作子模块">操作子模块&lt;/h3>
&lt;p>在子模块的文件夹内部，我们的各种操作都是对子模块的项目产生作用，比如 push 就是将子模块 push 到子模块的 remote repository。&lt;/p>
&lt;p>所以需要单独修改子模块，只需要 cd 到子模块内，把子模块当成一个普通的 git 项目即可。&lt;/p>
&lt;h2 id="克隆含有子模块的项目">克隆含有子模块的项目&lt;/h2>
&lt;p>克隆包含子模块的项目有两种方法：&lt;/p>
&lt;ol>
&lt;li>先克隆父项目，再更新子模块&lt;/li>
&lt;li>递归克隆整个项目。&lt;/li>
&lt;/ol>
&lt;h3 id="先克隆父项目再更新子模块">先克隆父项目，再更新子模块&lt;/h3>
&lt;p>这种方法有以下步骤：&lt;/p>
&lt;ol>
&lt;li>克隆父项目：&lt;code>git clone xxx&lt;/code>。注意这种情况下，像之前说的，在父项目中的操作，只对父项目产生作用，所以子项目不会被 clone。&lt;/li>
&lt;li>查看子模块：&lt;code>git submodule&lt;/code>。会发现子模块前面有一个 &lt;code>-&lt;/code>，说明子模块文件还未被 clone（为空文件夹）。
&lt;pre>&lt;code class="language-bash">$ git submodule
-e33f854d3f51f5ebd771a68da05ad0371a3c0570 xxx
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>初始化子模块：&lt;code>git submodule init&lt;/code>。在父模块 clone 之后运行一次，就行了。&lt;/li>
&lt;li>更新子模块：&lt;code>git submodule update&lt;/code>。运行后子模块被 clone，整个项目就 ready 了。&lt;/li>
&lt;/ol>
&lt;h3 id="递归克隆整个项目">递归克隆整个项目&lt;/h3>
&lt;p>clone 的时候，添加 &lt;code>--recursive&lt;/code> 指令，递归克隆子模块，一步到位。&lt;/p>
&lt;pre>&lt;code class="language-bash">git clone xxxx --recursive
&lt;/code>&lt;/pre>
&lt;h2 id="删除子模块">删除子模块&lt;/h2>
&lt;p>删除子模块比较麻烦，需要手动删除相关的文件，否则在添加子模块时有可能出现错误&lt;/p>
&lt;p>以删除 assets 文件夹为例&lt;/p>
&lt;ol>
&lt;li>
&lt;p>删除子模块文件夹&lt;/p>
&lt;pre>&lt;code>$ git rm --cached assets
$ rm -rf assets
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>删除 .gitmodules 文件中相关子模块信息&lt;/p>
&lt;pre>&lt;code>[submodule &amp;quot;assets&amp;quot;]
path = assets
url = https://github.com/maonx/vimwiki-assets.git
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>删除 .git/config 中的相关子模块信息&lt;/p>
&lt;pre>&lt;code>[submodule &amp;quot;assets&amp;quot;]
url = https://github.com/maonx/vimwiki-assets.git
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>删除 .git 文件夹中的相关子模块文件&lt;/p>
&lt;pre>&lt;code>$ rm -rf .git/modules/assets
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol></description></item><item><title>使用 Github actions 自动发布 Hugo 博客</title><link>https://Jimall.github.io/technology/posts/04.hugoactions/</link><pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/04.hugoactions/</guid><description>&lt;p>使用 hugo 写博客的时候，每次增加文章，需要本地构建之后发布到 github 上通过 github pages 服务展示页面，不难想到可以使用 CI 的方法，将构建的过程自动化，实现写博文 push 到 github 即可自动构建并发布到 github pages。&lt;/p>
&lt;p>搞的过程中坑比较多，记录为一个教程，供各位参考。&lt;/p>
&lt;p>我折腾过程中的参考：&lt;a href="https://tianhui.xin/blog/2019/11/17/hugousegithubactionstopages/">https://tianhui.xin/blog/2019/11/17/hugousegithubactionstopages/&lt;/a>&lt;/p>
&lt;h2 id="创建代码仓库和-github-pages-仓库">创建代码仓库和 github pages 仓库&lt;/h2>
&lt;p>构建过程中采用两个仓库：&lt;/p>
&lt;ol>
&lt;li>代码仓库，github pages 在这里构建并发布，我们设为 &lt;code>username.github.io.source&lt;/code>&lt;/li>
&lt;li>github pages 仓库，用于存放构建好的文件，github pages 服务会根据构建好的文件展示我们的博。客，我们设为 &lt;code>username.github.io&lt;/code>
（username 改为你自己的 github username）&lt;/li>
&lt;/ol>
&lt;p>简单说来就是根据代码仓库的文件构建，构建好之后发布到 github pages 仓库，github pages 仓库由于有 github 提供的服务，会自动展示我们的 blog。&lt;/p>
&lt;h3 id="创建-github-pages-仓库">创建 github pages 仓库&lt;/h3>
&lt;p>没啥特别，github 上创建一个空仓库 &lt;code>username.github.io&lt;/code>&lt;/p>
&lt;h3 id="创建代码仓库">创建代码仓库&lt;/h3>
&lt;p>这个仓库和我们本地直接关联，创建有一些细节需要注意，我下面的过程给各位参考：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>github 创建空仓库 &lt;code>username.github.io.source&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地找个空文件夹，比如叫 &lt;code>HugoBlog&lt;/code>，进去之后初始化 Hugo Blog：&lt;code>hugo new site .&lt;/code>
&lt;img src="https://cdn.jsdelivr.net/gh/shangjihao/images/blog/20210531130745.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>初始化 git 仓库：&lt;code>git init&lt;/code>
&lt;img src="https://cdn.jsdelivr.net/gh/shangjihao/images/blog/20210531130806.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加主题文件，这步需要注意，需要使用 git submodule 来进行（照着做就完了，不需要深入了解），比如我这边采用的主题文件为 &lt;code>joway/hugo-theme-yinyang&lt;/code>，那么命令为：&lt;code>git submodule add git@github.com:joway/hugo-theme-yinyang.git themes/yinyang&lt;/code>
&lt;img src="https://cdn.jsdelivr.net/gh/shangjihao/images/blog/20210531130855.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后根据主题去配置去添加文章，用 &lt;code>hugo serve&lt;/code> 看看效果，确定配置没问题&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后是关键的一部，添加 workflows 文件，用于 github actions 构建。创建 &lt;code>.github/workflows/gh-pages.yml&lt;/code> 文件，将下面的内容复制进去，并且根据自己的情况修改下面 TODO 表明的类。&lt;/p>
&lt;pre>&lt;code class="language-yml"> name: github pages CI # 自动化的名称，随便取
on:
push: # push的时候触发
branches:
- main # TODO 改成 username.github.io.source 的对应主分支
jobs:
build:
runs-on: ubuntu-latest
steps:
- name: checkout
uses: actions/checkout@master
with:
submodules: true
- name: Setup Hugo
uses: peaceiris/actions-hugo@v2
with:
hugo-version: '0.83.1'
extended: true
- name: Build
run: hugo --minify
- name: Deploy
uses: peaceiris/actions-gh-pages@v3
with:
deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 这个 ACTIONS_DEPLOY_KEY 需要注意，后面会用到
external_repository: username/username.github.io # TODO 改成对应的仓库名
publish_branch: main # TODO 发布到 username.github.io 的相应分支
publish_dir: ./public
&lt;/code>&lt;/pre>
&lt;p>需要知道的是，基本上最后搞不出来都会是因为这个文件，所以务必仔细检查配置，如果配置正确的情况下还是出现问题那么需要去看 hugo github actions 的提供方的文档，也就是 peaceiris/actions-gh-pages 这个项目。（我就是网上折腾了好久发现是配置不对 xD）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加公钥和私钥。代码仓库需要有 github pages 的写入权限，需要添加公钥和私钥：（注意这个和 github 添加 ssh 链接的私钥不一样，无论如何都要做这一步）&lt;/p>
&lt;ol>
&lt;li>使用 &lt;code>ssh-keygen -t rsa -b 4096 -C &amp;quot;$(git config user.email)&amp;quot;&lt;/code> 创建公钥私钥，在当前文件夹生成即可：
&lt;img src="https://cdn.jsdelivr.net/gh/shangjihao/images/blog/20210531143428.png" alt="">&lt;/li>
&lt;li>将生产后的私钥（不带后缀名的）添加到代码仓库，仓库的 Settings 中点击 Secrets，然后添加咱们刚刚生成的私钥，name 为 ACTIONS_DEPLOY_KEY，注意 name 一定要是这个，因为上面的文件中配置的是这个名字&lt;/li>
&lt;li>然后将公钥（带 pub 后缀名的）添加到 github pages 仓库，Settings 中点击 Deploy keys，添加公钥，Allow write access一定要勾上，否则会无法提交&lt;/li>
&lt;li>公钥和私钥可以删掉，后面不需要了&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>将代码仓库 add commit push 到远程，基本操作，不多赘述&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看代码仓库的 actions，这个时候基本会 build 完成，如果失败了仔细检查步骤。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="others">others&lt;/h2>
&lt;p>本次折腾过程中看到一些不了解的东西，打算去折腾一下：&lt;/p>
&lt;ol>
&lt;li>非对称加密&lt;/li>
&lt;li>&lt;a href="https://Jimall.github.io/posts/05.gitsubmodule/">git submodule&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>.gitignore 的写法</title><link>https://Jimall.github.io/technology/posts/03.gitignore/</link><pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/03.gitignore/</guid><description>&lt;p>在一个项目中，并不是所有的文件都需要使用 Git 进行版本管理，比如一些自动生成的文件，这时候可以在项目中添加 .gitignore 文件来忽略一些不需要进行版本管理的文件。&lt;/p>
&lt;p>.gitignore 有一套语法，下面介绍一下：&lt;/p>
&lt;h2 id="gitignore-文件语法">.gitignore 文件语法&lt;/h2>
&lt;p>首先 .gitignore 文件每一行定义一条规则，从上到下进行解释的。&lt;/p>
&lt;h3 id="注释">注释&lt;/h3>
&lt;p>使用 &lt;code>#&lt;/code> 行注释&lt;/p>
&lt;h3 id="通配符匹配">通配符匹配&lt;/h3>
&lt;p>.gitignore 可以使用通配符匹配，并且常常用到（&lt;code>*&lt;/code> 用的比较多）&lt;/p>
&lt;p>&lt;code>*&lt;/code> 表示一个或多个字符&lt;/p>
&lt;p>&lt;code>[]&lt;/code> 表示范围&lt;/p>
&lt;p>&lt;code>?&lt;/code> 表示单个字符&lt;/p>
&lt;h3 id="忽略文件和否定忽略文件">忽略文件和否定忽略文件&lt;/h3>
&lt;p>每一行，写路径即可忽略掉相应的内容，在路径前使用 &lt;code>!&lt;/code> 即可取消忽略相应路径，比如：&lt;/p>
&lt;pre>&lt;code class="language-gitignore"># 忽略 .exe 文件
*.exe
# 否定忽略 main.exe，由于文件是从上到下进行解释的，所以上下两条规则的意思是忽略除了 main.exe 的所有 .exe 文件
!main.exe
# 忽略 build 文件夹
build/
&lt;/code>&lt;/pre>
&lt;h3 id="防止递归">防止递归&lt;/h3>
&lt;p>直接制定文件名，实际上是递归的忽略，也就是说 &lt;code>*.exe&lt;/code> 会忽略目录下的所有 &lt;code>.exe&lt;/code> 文件。&lt;/p>
&lt;p>使用 &lt;code>/&lt;/code> 防止递归：&lt;/p>
&lt;pre>&lt;code class="language-gitignore"># 仅在当前目录下忽略 temp 文件， 但不包括子目录下的 subdir/temp
/temp
# 忽略 build/ 文件夹下的所有文件
build/
# 忽略 doc/notes.txt, 不包括 doc/server/arch.txt
doc/*.txt
# 忽略所有的 .pdf 文件 在 doc/ 下的所有 .txt 文件
doc/**/*.txt
&lt;/code>&lt;/pre>
&lt;h2 id="gitignore-vscode-插件">gitignore vscode 插件&lt;/h2>
&lt;p>vscode 有 gitignore 插件可以帮助我们写 .gitignore 文件，在 extension store 下载，使用 CTRL+SHIFT+P 运行 add gitignore 可以自动生成不同语言的 .gitignore 文件模板，同时可以将当前文件 add .gitignore。&lt;/p></description></item><item><title>一些有用的命令行工具</title><link>https://Jimall.github.io/technology/posts/articleshare/commandline/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/articleshare/commandline/</guid><description>&lt;p>看到一篇文章，介绍了一些有用的命令行工具，挺有意思的&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/373633350">https://zhuanlan.zhihu.com/p/373633350&lt;/a>&lt;/p>
&lt;p>个人感觉比较有用的：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>httpie：&lt;code>sudo apt install httpie&lt;/code>&lt;/p>
&lt;p>感觉命令格式比 CUrl 友好&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bat: &lt;code>sudo apt install bat&lt;/code>&lt;/p>
&lt;p>可以完全替代 cat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>gpustat: &lt;code>sudo apt install gpustat&lt;/code>&lt;/p>
&lt;p>查询 GPU 状态，GPU 版本的 top&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ohmyzsh:&lt;/p>
&lt;p>这个自然不用多说了，就是牛&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Anki 的配置</title><link>https://Jimall.github.io/technology/posts/usefultools/anki/</link><pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/usefultools/anki/</guid><description>&lt;p>Anki 在安装和下载上没有很大的难度，电脑端直接安装，Android 端 Google Play 直接下载。&lt;/p>
&lt;p>但是在同步方面有一定的问题，因为同步使用 Ankiweb 服务，这是个国外的服务，需要挂梯子。&lt;/p>
&lt;p>需要注意的事情是 PC 端直接挂梯子会发现登录报错，这个时候需要配置 HTTP_PROXY 环境变量：&lt;a href="https://www.zhihu.com/question/414092584/answer/1691605650">每次打开anki都提示发生网络错误 ? - 劳模盐的回答 - 知乎
&lt;/a>&lt;/p>
&lt;p>配置完之后就能愉快的挂梯子同步了。&lt;/p></description></item><item><title>Leetcode-082-删除链表中的重复元素II</title><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-082-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</link><pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-082-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</guid><description>&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/&lt;/a>&lt;/p>
&lt;p>tag：链表 虚拟头&lt;/p>
&lt;p>如果下两个节点值相等，就证明有连续相等的值，然后进行顺序遍历直到找到不相等的值作为下一个节点。&lt;/p>
&lt;p>这题更加体现虚拟头的作用，可以直接开始判断，如果不使用虚拟头则感觉要分情况讨论。&lt;/p>
&lt;pre>&lt;code class="language-Java">/**
* Definition for singly-linked list.
* public class ListNode {
* int val;
* ListNode next;
* ListNode() {}
* ListNode(int val) { this.val = val; }
* ListNode(int val, ListNode next) { this.val = val; this.next = next; }
* }
*/
class Solution {
public ListNode deleteDuplicates(ListNode head) {
ListNode dummy = new ListNode();
dummy.next = head;
ListNode current = dummy;
// 循环内的流程先画好图想清楚，基本画好图根据图写好代码，后面就是一些细节问题
while (current.next != null &amp;amp;&amp;amp; current.next.next != null) {
// 如果下两个值相等
if (current.next.val == current.next.next.val) {
ListNode temp = current.next.next;
while (temp.next != null &amp;amp;&amp;amp; temp.next.val == temp.val) {
temp = temp.next;
}
// 这里不修改当前头，因为画图可以发现可能会继续删
current.next = temp.next;
} else {
current = current.next;
}
}
return dummy.next;
}
}
&lt;/code>&lt;/pre></description></item><item><title>Leetcode-083-删除排序链表中的重复元素</title><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link><pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid><description>&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/&lt;/a>&lt;/p>
&lt;p>tag：链表&lt;/p>
&lt;p>简单，不需要很多技巧，判断后面的节点是否与当前节点值相等，如果相等就删除，遍历一遍即可。&lt;/p>
&lt;pre>&lt;code class="language-Java">/**
* Definition for singly-linked list.
* public class ListNode {
* int val;
* ListNode next;
* ListNode() {}
* ListNode(int val) { this.val = val; }
* ListNode(int val, ListNode next) { this.val = val; this.next = next; }
* }
*/
class Solution {
public ListNode deleteDuplicates(ListNode head) {
ListNode cur = head;
while (cur != null) {
// 如果下一个节点与当前节点值相等，则删除
if (cur.next != null &amp;amp;&amp;amp; cur.next.val == cur.val) {
cur.next = cur.next.next;
} else {
cur = cur.next;
}
}
return head;
}
}
&lt;/code>&lt;/pre></description></item><item><title>Kotlin Learning Snippets</title><link>https://Jimall.github.io/technology/posts/01.kotlin-learning-snippets/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/01.kotlin-learning-snippets/</guid><description>&lt;p>最近看到 Kotlin 可以做桌面应用甚至 Multiplatform 应用，感觉后面能用上，于是学一波！下面记录一些有意义的 Snippets。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="学习材料">学习材料&lt;/h2>
&lt;p>&lt;a href="https://play.kotlinlang.org/koans/overview">Idea Edu Plugin 课程 Kotlin Koan&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://kotlinlang.org/docs/home.html">Kotlin 官网文档&lt;/a>&lt;/p>
&lt;p>JetBrains 的社区建设做得很好，文档写的很好，把 Kotlin Koan 过一遍基本就没啥问题了。&lt;/p>
&lt;p>这种看文档去解决练习的方式个人认为是最利于有一定经验的编程者上手一个技术的方法。&lt;/p>
&lt;h2 id="函数声明">函数声明&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">fun sum(a: Int, b: Int): Int {
return a + b
}
fun sum(a: Int = 1, b: Int = 2): Int = a + b
&lt;/code>&lt;/pre></description></item><item><title>Leetcode-21-合并两个有序链表</title><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description>&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/&lt;/a>&lt;/p>
&lt;p>tag：归并排序 链表 虚拟头&lt;/p>
&lt;p>链表和数组是类似的，所以合并两个有序链表可以借鉴合并两个有序数组的方法，不难想到使用归并排序的策略。&lt;/p>
&lt;p>做链表题是时刻考虑判空，&lt;strong>考虑到传入的 ListNode 可能为 null，即返回的链表可能为 null，使用虚拟头解决来避免判空&lt;/strong>。&lt;/p>
&lt;pre>&lt;code class="language-Java">/**
* Definition for singly-linked list.
* public class ListNode {
* int val;
* ListNode next;
* ListNode() {}
* ListNode(int val) { this.val = val; }
* ListNode(int val, ListNode next) { this.val = val; this.next = next; }
* }
*/
class Solution {
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
// 虚拟头
ListNode result = new ListNode();
ListNode current = result;
// 以下就是归并操作
ListNode left = l1;
ListNode right = l2;
while (left != null &amp;amp;&amp;amp; right != null) {
if (left.val &amp;lt; right.val) {
current.next = left;
current = current.next;
left = left.next;
} else {
current.next = right;
current = current.next;
right = right.next;
}
}
while (left != null) {
current.next = left;
current = current.next;
left = left.next;
}
while (right != null) {
current.next = right;
current = current.next;
right = right.next;
}
return result.next;
}
}
&lt;/code>&lt;/pre></description></item><item><title>LinkedList</title><link>https://Jimall.github.io/technology/posts/leetcode/topic/01.%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/topic/01.%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</guid><description>&lt;h2 id="链表结构">链表结构&lt;/h2>
&lt;p>线性结构&lt;/p>
&lt;pre>&lt;code class="language-Java">public class ListNode {
int val;
ListNode next;
}
&lt;/code>&lt;/pre>
&lt;h2 id="链表的基本操作">链表的基本操作&lt;/h2>
&lt;p>要熟悉链表的常用操作和各自复杂度。&lt;/p>
&lt;p>插入操作：O(N)&lt;/p>
&lt;p>删除操作：O(N)&lt;/p>
&lt;p>查找操作：O(N)&lt;/p>
&lt;p>要知道为什么是这样的复杂度。&lt;/p>
&lt;h2 id="解题注意事项">解题注意事项&lt;/h2>
&lt;p>解题时心中要时刻默念：&lt;/p>
&lt;ol>
&lt;li>先画图，再解题&lt;/li>
&lt;li>时刻考虑判空&lt;/li>
&lt;/ol>
&lt;p>链表题只要能画出图，解题的方向基本不会出问题，容易出错的地方在判空上。&lt;/p>
&lt;h2 id="解题技巧">解题技巧&lt;/h2>
&lt;p>链表常用的解题技巧：&lt;/p>
&lt;ol>
&lt;li>虚拟头&lt;/li>
&lt;li>快慢指针&lt;/li>
&lt;/ol>
&lt;h3 id="虚拟头">虚拟头&lt;/h3>
&lt;p>虚拟头在返回的链表头结点可能为 null 的时候可以用上，利用虚拟头可以避免对返回值判空，可以避免分类讨论，是链表题中很常见的一个技巧。&lt;/p>
&lt;p>虚拟头的常见模式如下，先创建一个链表，然后将链表头和输入链表连接：&lt;/p>
&lt;pre>&lt;code class="language-Java">ListNode dummy = new ListNode();
// 将虚拟头和输入链表连接
dummy.next = input;
&lt;/code>&lt;/pre>
&lt;p>然后进行各种操作之后返回虚拟头的下一个节点，这样即使 input 全部删除了，即返回值为 null，也不用作判断。&lt;/p>
&lt;pre>&lt;code class="language-Java">return dummy.next;
&lt;/code>&lt;/pre>
&lt;h3 id="快慢指针">快慢指针&lt;/h3>
&lt;p>快慢指针的技巧用在一些特定的题目中，是一种固定的套路。&lt;/p>
&lt;p>主要用来判断链表成环：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">https://leetcode-cn.com/problems/reverse-linked-list-ii/&lt;/a>&lt;/p>
&lt;p>同时也可以利用快慢指针找到链表中点：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/&lt;/a>&lt;/p>
&lt;h2 id="题目推荐">题目推荐&lt;/h2>
&lt;ul>
&lt;li>21.合并两个有序链表——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">Leetcode&lt;/a>✅&lt;/li>
&lt;li>82.删除排序链表中的重复元素II——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-082-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">Leetcode&lt;/a>✅&lt;/li>
&lt;li>83.删除排序链表中的重复元素——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-083-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">Leetcode&lt;/a>✅&lt;/li>
&lt;li>86.分隔链表——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/partition-list/">Leetcode&lt;/a>✅&lt;/li>
&lt;li>92.反转链表 II——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">Leetcode&lt;/a>✅&lt;/li>
&lt;li>138.复制带随机指针的链表——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/">题解&lt;/a>&lt;a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">Leetcode&lt;/a>&lt;/li>
&lt;li>141.环形链表——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/linked-list-cycle/">Leetcode&lt;/a>✅&lt;/li>
&lt;li>142.环形链表 II——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">Leetcode&lt;/a>✅&lt;/li>
&lt;li>143.重排链表——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/reorder-list/">Leetcode&lt;/a>✅&lt;/li>
&lt;li>148.排序链表——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/sort-list/">Leetcode&lt;/a>&lt;/li>
&lt;li>206.反转链表——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/reverse-linked-list/">Leetcode&lt;/a>✅&lt;/li>
&lt;li>234.回文链表——&lt;a href="https://Jimall.github.io/posts/leetcode/problem/leetcode-092-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/">题解&lt;/a>✅&lt;a href="https://leetcode-cn.com/problems/palindrome-linked-list/">Leetcode&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title/><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</link><pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</guid><description>&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/reorder-list/">https://leetcode-cn.com/problems/reorder-list/&lt;/a>&lt;/p>
&lt;p>tag：链表&lt;/p>
&lt;p>这题难度本身不大，但是涉及很多技巧，一方面是使用快慢指针寻找链表中点，一方面是反转链表，然后就是链表合并。&lt;/p>
&lt;p>找到链表中点，反转后半部分的链表然后进行链表合并即可。&lt;/p>
&lt;p>找链表中点可以使用快慢指针的方法，有一道 Leetcode 题：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/&lt;/a>&lt;/p>
&lt;p>注意找链表中点有讲究：&lt;/p>
&lt;p>如果条件为 &lt;code>fast != null &amp;amp;&amp;amp; fast.next != null&lt;/code>，那么偶数长度的链表中点为中间两个的第二个，如果条件为 &lt;code>fast.next != null &amp;amp;&amp;amp; fast.next.next != null&lt;/code>，那么偶数长度的链表中点为中间两个的第一个。&lt;/p>
&lt;p>那么代码如下：&lt;/p>
&lt;pre>&lt;code class="language-Java">/**
* Definition for singly-linked list.
* public class ListNode {
* int val;
* ListNode next;
* ListNode() {}
* ListNode(int val) { this.val = val; }
* ListNode(int val, ListNode next) { this.val = val; this.next = next; }
* }
*/
class Solution {
public void reorderList(ListNode head) {
if (head == null) {
return;
}
ListNode mid = findMiddle(head);
ListNode head2 = mid.next;
mid.next = null;
head2 = reverse(head2);
ListNode current = head;
ListNode current2 = head2;
while (current2 != null) {
ListNode next = current.next;
current.next = current2;
current = next;
ListNode next2 = current2.next;
current2.next = next;
current2 = next2;
}
}
public ListNode findMiddle(ListNode head) {
if (head == null || head.next == null || head.next.next == null) {
return head;
}
ListNode slow = head;
ListNode fast = head;
while (fast.next != null &amp;amp;&amp;amp; fast.next.next != null) {
slow = slow.next;
fast = fast.next.next;
}
return slow;
}
public ListNode reverse(ListNode head) {
ListNode pre = null;
ListNode current = head;
while (current != null) {
ListNode next = current.next;
current.next = pre;
pre = current;
current = next;
}
return pre;
}
}
&lt;/code>&lt;/pre></description></item><item><title>Leetcode-141-环形链表</title><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link><pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid><description>&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/&lt;/a>&lt;/p>
&lt;p>tag：链表 快慢指针&lt;/p>
&lt;p>&lt;strong>使用快慢指针判断链表成环一个很常见的技巧&lt;/strong>，原理就是速度快的人在没成环的时候一定不可能被速度慢的人追上。需要注意的是，比较是否相等的时候，比较的是 node 是否相等，而不是 val 是否相等。&lt;/p>
&lt;p>注意，让两个指针初始值为 head，因为另一种形式的环形链表题一定要两个指针从 head 开始走，防止搞混所以这样操作。&lt;/p>
&lt;pre>&lt;code class="language-Java">/**
* Definition for singly-linked list.
* class ListNode {
* int val;
* ListNode next;
* ListNode(int x) {
* val = x;
* next = null;
* }
* }
*/
public class Solution {
public boolean hasCycle(ListNode head) {
if (head == null) {
return false;
}
ListNode slow = head;
ListNode fast = head;
while (slow != null &amp;amp;&amp;amp; fast != null) {
slow = slow.next;
if (fast.next == null) {
return false;
}
fast = fast.next.next;
// 这里不考虑 slow 和 fast 都为 null 的情况，是因为 fast 一定先为 null，那个时候程序早就返回了，不可能同时为 null
if (slow == fast) {
return true;
}
}
return false;
}
}
&lt;/code>&lt;/pre></description></item><item><title>Leetcode-142-环形链表II</title><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link><pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid><description>&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/&lt;/a>&lt;/p>
&lt;p>tag：链表 快慢指针&lt;/p>
&lt;p>判断链表成环我们已经会了，找到环形链表的开始节点需要通过数学推导发现规律得到：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/shangjihao/images/blog/20210624102109.png" alt="">&lt;/p>
&lt;p>所以代码如下，值得注意的是 slow 和 fast 的开始节点一定要为 head，不然这种直接使用方法不成立：&lt;/p>
&lt;pre>&lt;code class="language-Java">/**
* Definition for singly-linked list.
* class ListNode {
* int val;
* ListNode next;
* ListNode(int x) {
* val = x;
* next = null;
* }
* }
*/
public class Solution {
public ListNode detectCycle(ListNode head) {
if (head == null) {
return null;
}
ListNode slow = head;
ListNode fast = head;
// 可以简化掉 slow != null，因为 fast 一定先为 null
while (fast != null) {
slow = slow.next;
if (fast.next == null) {
return null;
}
fast = fast.next.next;
if (slow == fast) {
ListNode temp = head;
while (temp != slow) {
temp = temp.next;
slow = slow.next;
}
return temp;
}
}
return null;
}
}
&lt;/code>&lt;/pre></description></item><item><title/><link>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/leetcode/problem/leetcode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description/></item></channel></rss>