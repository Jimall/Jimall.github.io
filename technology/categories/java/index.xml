<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on BLOG</title><link>https://Jimall.github.io/technology/categories/java/</link><description>Recent content in Java on BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://Jimall.github.io/technology/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 集合框架 Map 接口</title><link>https://Jimall.github.io/technology/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/map%E6%8E%A5%E5%8F%A3/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/map%E6%8E%A5%E5%8F%A3/</guid><description>&lt;p>图示：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/SUSTechee/images/blog/20210310083541.png" alt="">&lt;/p>
&lt;p>Map 通过 key-value 形式存元素，每个元素称为 entry，即一个 entry 包含 key 和 value 两个值。&lt;/p>
&lt;h2 id="map-接口-api">Map 接口 api&lt;/h2>
&lt;p>信息：isEmpty(), size()&lt;/p>
&lt;p>添加修改：put(key, value) 如果 key 存在就会修改，否则添加&lt;/p>
&lt;p>查找：containKey(), containValue()&lt;/p>
&lt;p>遍历：entrySet() 返回映射关系的 set 视图，keySet() 返回 key 的 set 视图，values() 返回 value 的 collection 视图&lt;/p>
&lt;p>删除：remove(key)，clear()&lt;/p>
&lt;h2 id="常用集合">常用集合&lt;/h2>
&lt;h3 id="hashmap">HashMap&lt;/h3>
&lt;p>了解 HashMap，首先需要了解哈希算法：&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/higerMan/p/11907117.html">哈希冲突及四种解决方法&lt;/a>&lt;/p>
&lt;p>四种解决方法：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>开放地址法
1.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拉链法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>建立公共溢出区&lt;/p>
&lt;p>建立公共溢出区存储所有哈希冲突的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>再哈希法&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>然后需要了解红黑树：&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/v_JULY_v/article/details/6105630">红黑树介绍和实现&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>红黑树是平衡的二叉查找树，和 AVL tree 是类似的，不同的是 AVL tree 和红黑树维持平衡的规则不太一样。&lt;/li>
&lt;li>红黑树的关键性质：
&lt;ul>
&lt;li>每个结点要么是红的要么是黑的。&lt;/li>
&lt;li>根结点是黑的。&lt;/li>
&lt;li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。&lt;/li>
&lt;li>如果一个结点是红的，那么它的两个儿子都是黑的。&lt;/li>
&lt;li>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>理解红黑树的关键是理解平衡和理解二叉查找树，二叉查找树插入、删除和查找的开销都是 O(h)，由于红黑树平衡，那么 h 最大为 log(n)，所以红黑树插入、删除和查找的开销为 log(n)&lt;/li>
&lt;/ul>
&lt;p>开始看 HashMap 解析博文，根据博文再看 HashMap 源码进行理解：&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/38615394">HashMap 结构详解&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/127147909">HashMap 详解&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/127147909">HashMap 原理详解（面试题）&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>HashMap 的底层是数组、链表和红黑树&lt;/li>
&lt;li>数组是用于进行映射的，hashCode 之后就可以直接存在数组上，然后就可以 O(1) 查找，同时数组长度不够的时候带有扩容机制 resize，但是注意 resize 是很耗性能的&lt;/li>
&lt;li>hashCode 之后会产生 hash 碰撞，这样在数组上的同一位置会有多个结果，所以用链表串起来，在查找的时候再搜一遍链表即可&lt;/li>
&lt;li>链表的搜索复杂度为 O(n)，这样链表太长的情况下会很慢，这个时候，把链表想象成极端情况下的二叉树，就不难想到把链表平衡树化，采取的操作是构建为红黑树，这样平衡之后就可以 O(logn) 搜索&lt;/li>
&lt;li>HashMap 线程不安全&lt;/li>
&lt;/ul>
&lt;h3 id="linkedhashmap">LinkedHashMap&lt;/h3>
&lt;p>LinkedHashMap 和 HashMap 几乎一样，事实上，LinkedHashMap 继承自 HashMap 唯一的不同在于遍历顺序上：&lt;/p>
&lt;p>&lt;a href="https://sunweiguo.github.io/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/">LinkedHashMap 和 HashMap 比较&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>&lt;code>HashMap&lt;/code>的输出顺序与元素的输入顺序无关，因为遍历的时候它自己根据读取方便来确定散列值取数据，&lt;code>LinkedHashMap&lt;/code>可以按照输入顺序输出，也可以根据读取元素的顺序输出&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.jianshu.com/p/181df0893158">LinkedHashMap 详解&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>LinkedHashMap 维护了一个 LinkedHashMapEntry 双向链表，在遍历的时候 iterator 在 LinkedHashMapEntry 上遍历。&lt;/li>
&lt;/ul>
&lt;h3 id="treemap">TreeMap&lt;/h3>
&lt;p>&lt;a href="https://www.jianshu.com/p/d9ad7f6d75a0">TreeMap 详解&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>TreeMap 就是一棵红黑树，有可以排序的特性&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.csdn.net/xlgen157387/article/details/47907721#:~:text=HashMap%E5%92%8CTreeMap%E6%AF%94%E8%BE%83,Map%E6%97%B6%E5%80%99%E6%89%8D%E7%94%A8TreeMap.">TreeMap 和 HashMap 的比较&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>HashMap:适用于在Map中插入、删除和定位元素。&lt;/li>
&lt;li>Treemap:适用于按自然顺序或自定义顺序遍历键（key）。&lt;/li>
&lt;li>HashMap通常比TreeMap快一点（树和哈希表的数据结构使然），建议多使用HashMap,在需要排序的Map时候才用TreeMap.&lt;/li>
&lt;li>HashMap 非线程安全 TreeMap 非线程安全&lt;/li>
&lt;li>HashMap的结果是没有排序的，而TreeMap输出的结果是排好序的。&lt;/li>
&lt;/ul>
&lt;h3 id="concurrenthashmap">ConcurrentHashMap&lt;/h3>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/40327960">ConcurrentHashMap 和 HashMap 的对比&lt;/a>&lt;/p>
&lt;p>总结：&lt;/p>
&lt;ul>
&lt;li>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。&lt;/li>
&lt;/ul>
&lt;h3 id="hashtable">Hashtable&lt;/h3>
&lt;p>Hashtable 和 HashMap 实现很类似，但是有一定的不同：&lt;/p>
&lt;p>&lt;strong>1.实现&lt;/strong>：HashMap继承的类是AbstractMap类，而Hashtable继承的是Dictionary类，而Dictionary是一个过时的类，因此通常情况下建议使用HashMap而不是使用Hashtable&lt;/p>
&lt;p>&lt;strong>2.内部结构&lt;/strong>：其实HashMap与Hashtable内部基本都是使用&lt;strong>数组-链表&lt;/strong>的结构，但是HashMap引入了红黑树的实现，内部相对来说更加复杂而性能相对来说应该更好&lt;/p>
&lt;p>&lt;strong>3.NULL值控制&lt;/strong>：通过前面的介绍我们知道Hashtable是不允许key-value为null值的，Hashtable对于key-value为空的情况下将抛出NullPointerException，而HashMap则是允许key-value为null的，HashMap会将key=null方法index=0的位置。&lt;/p>
&lt;p>&lt;strong>4.线程安全&lt;/strong>：通过阅读源码可以发现Hashtable的方法中基本上都是有synchronized关键字修饰的，但是HashMap是线程不安全的，故对于单线程的情况下来说HashMap的性能更优于Hashtable，单线程场景下建议使用HashMap.&lt;/p>
&lt;p>在源码里面经常出现 transient 关键字：&lt;a href="https://www.cnblogs.com/lanxuezaipiao/p/3369962.html">transient 关键字&lt;/a>，总结来说就是：为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中&lt;/p></description></item></channel></rss>