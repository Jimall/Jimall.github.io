<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SpringFramework on BLOG</title><link>https://Jimall.github.io/technology/categories/springframework/</link><description>Recent content in SpringFramework on BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 03 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://Jimall.github.io/technology/categories/springframework/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring IoC 组件详解</title><link>https://Jimall.github.io/technology/posts/java/spring/ioc/spring%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/java/spring/ioc/spring%E7%AC%94%E8%AE%B0/</guid><description>&lt;p>Spring 有两大核心机制：&lt;/p>
&lt;ol>
&lt;li>IoC (Inverse of Control, 控制反转)&lt;/li>
&lt;li>AOP (Aspect-Oriented Programming, 面向切面编程)&lt;/li>
&lt;/ol>
&lt;p>学习 Spring 的核心（单指 Spring 本身，不包括别的组件）就在于学习理解这两大核心机制。&lt;/p>
&lt;p>这篇文章我们来讲讲 IoC。&lt;/p>
&lt;h2 id="ioc">IoC&lt;/h2>
&lt;p>IoC 是 Spring 的核心机制。&lt;/p>
&lt;h3 id="什么是-ioc">什么是 IoC？&lt;/h3>
&lt;p>IoC (Inversion of Control)，即“控制反转”。它不是一种技术，而是一种设计思想。在 Java 开发中，IoC 意味着将你设计好的对象交给容器控制，而不是在你的对象内部控制（控制的意思是说对象内部需要通过 new 等方式创建依赖对象，需要我们自己进行创建）。&lt;/p>
&lt;p>如何理解好 IoC 呢？理解好 Ioc 的关键是要明确”谁控制谁？控制什么？为何是反转？哪些方面反转了？”：&lt;/p>
&lt;p>”谁控制谁？控制什么？“：在传统 Java SE 程序设计中，我们直接在对象内部通过 new 创建对象，是对象主动去创建依赖对象，而 &lt;strong>IoC 通过一个专门的容器（称为 IoC 容器）来创建这些对象&lt;/strong>；谁控制谁？&lt;strong>IoC 容器控制了对象&lt;/strong>；控制什么？&lt;strong>控制了外部资源获取&lt;/strong>（不只是对象包括比如文件等）。&lt;/p>
&lt;p>“为何是反转？哪些方面反转了？”：有反转就有正转，传统应用程序由我们自己在程序中主动控制去获取依赖对象，也就是正转，而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？&lt;strong>因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转&lt;/strong>；哪些方面反转了？&lt;strong>依赖对象的获取反转&lt;/strong>。&lt;/p>
&lt;p>所以控制反转的意思就是，&lt;strong>IoC 容器控制对象，让依赖对象的获取反转&lt;/strong>。&lt;/p>
&lt;h3 id="ioc-能做什么">IoC 能做什么？&lt;/h3>
&lt;p>IoC 不是一种技术，而是一种设计思想，一个重要的面向对象编程的法则，&lt;strong>它能指导我们如何设计出松耦合、更优良的程序&lt;/strong>。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试。有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。&lt;/p>
&lt;p>IoC 很好的体现了面向对象设计法则中的好莱坞法则：“别找我们，我们找你”，即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。&lt;/p>
&lt;h3 id="di">DI&lt;/h3>
&lt;p>DI (Dependency Injection) 依赖注入。这也是 Spring 中的一个重要概念。&lt;/p>
&lt;p>依赖注入：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。&lt;/p>
&lt;p>理解 DI 的关键是：“谁依赖谁？为什么需要依赖？谁注入谁？注入了什么？”：&lt;/p>
&lt;p>”谁依赖于谁？“：&lt;strong>应用程序依赖于 IoC 容器&lt;/strong>&lt;/p>
&lt;p>”为什么需要依赖？“：&lt;strong>应用程序需要 IoC 容器来提供对象需要的外部资源&lt;/strong>&lt;/p>
&lt;p>“谁注入谁？”：&lt;strong>IoC 容器注入应用程序某个对象，应用程序依赖的对象&lt;/strong>&lt;/p>
&lt;p>”注入了什么？“：&lt;strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）&lt;/strong>&lt;/p>
&lt;p>&lt;strong>IoC 和 DI 有什么关系呢？其实它们是同一个概念的不同角度描述&lt;/strong>，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。&lt;/p>
&lt;h3 id="ioc-demo-和详细使用">IoC Demo 和详细使用&lt;/h3>
&lt;p>demo 放在代码里面，这样可以结合代码进行理解&lt;/p>
&lt;h3 id="参考">参考&lt;/h3>
&lt;p>IoC 部分，参考：&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/GoGleTech/article/details/79557416">https://blog.csdn.net/GoGleTech/article/details/79557416&lt;/a>&lt;/p>
&lt;h2 id="ioc-底层原理">IoC 底层原理&lt;/h2></description></item><item><title>Spring结合Junit进行单元测试</title><link>https://Jimall.github.io/technology/posts/java/spring/spring%E7%BB%93%E5%90%88junit%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/technology/posts/java/spring/spring%E7%BB%93%E5%90%88junit%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>&lt;p>由于 Spring 各种注解的使用需要结合 xml 配置文件，所以单元测试没有办法直接写，需要引入 Spring 对单元测试的支持。下面讲讲详细步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>引入 Spring-test 和 junit test 依赖：&lt;/p>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;4.13&amp;lt;/version&amp;gt;
&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;5.2.9.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>在测试类中添加 @RunWith 和 @ContextConfiguration 注解&lt;/p>
&lt;pre>&lt;code class="language-Java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&amp;quot;classpath:spring.xml&amp;quot;)
public class StudentTest {
@Autowired
public Student student;
@Test
public void testStudentCreation() {
System.out.println(student);
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;p>这样就可以正常使用了，需要注意的是，spring.xml 中需要配置才能使用 @Autowired 等注解：&lt;/p>
&lt;pre>&lt;code class="language-xml"> &amp;lt;context:component-scan base-package=&amp;quot;org.example&amp;quot;/&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>（同时 xml 文件头还需要引入 context 相关的域，alt+enter 即可）&lt;/p></description></item></channel></rss>