<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on BLOG</title><link>https://Jimall.github.io/categories/java/</link><description>Recent content in Java on BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://Jimall.github.io/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 集合框架 Map 接口</title><link>https://Jimall.github.io/tech/posts/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/map%E6%8E%A5%E5%8F%A3/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/map%E6%8E%A5%E5%8F%A3/</guid><description>图示：
Map 通过 key-value 形式存元素，每个元素称为 entry，即一个 entry 包含 key 和 value 两个值。
Map 接口 api 信息：isEmpty(), size()
添加修改：put(key, value) 如果 key 存在就会修改，否则添加
查找：containKey(), containValue()
遍历：entrySet() 返回映射关系的 set 视图，keySet() 返回 key 的 set 视图，values() 返回 value 的 collection 视图
删除：remove(key)，clear()
常用集合 HashMap 了解 HashMap，首先需要了解哈希算法：
哈希冲突及四种解决方法
四种解决方法：
开放地址法 1.
拉链法
建立公共溢出区
建立公共溢出区存储所有哈希冲突的数据。
再哈希法
然后需要了解红黑树：
红黑树介绍和实现
总结：
红黑树是平衡的二叉查找树，和 AVL tree 是类似的，不同的是 AVL tree 和红黑树维持平衡的规则不太一样。 红黑树的关键性质： 每个结点要么是红的要么是黑的。 根结点是黑的。 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。 如果一个结点是红的，那么它的两个儿子都是黑的。 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 理解红黑树的关键是理解平衡和理解二叉查找树，二叉查找树插入、删除和查找的开销都是 O(h)，由于红黑树平衡，那么 h 最大为 log(n)，所以红黑树插入、删除和查找的开销为 log(n) 开始看 HashMap 解析博文，根据博文再看 HashMap 源码进行理解：</description></item></channel></rss>