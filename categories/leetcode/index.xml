<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcode on BLOG</title><link>https://Jimall.github.io/categories/leetcode/</link><description>Recent content in Leetcode on BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://Jimall.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode-086-分隔链表</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</guid><description>题目链接：
https://leetcode-cn.com/problems/partition-list/
tag：链表 虚拟头
关键是构造小大两个链表，然后串起来。只要想到这个思路，代码实现就很简单了。
注意串的时候，需要将大链表的尾部设为 null，不然会成环。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode partition(ListNode head, int x) { ListNode current = head; ListNode dummySmall = new ListNode(); ListNode currentSmall = dummySmall; ListNode dummyLarge = new ListNode(); ListNode currentLarge = dummyLarge; while (current !</description></item><item><title>Leetcode-092-反转链表II</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</guid><description>题目链接：
https://leetcode-cn.com/problems/reverse-linked-list-ii/
tag：链表
在串中，部分反转可以通过先部分反转，再整体反转的思路来进行。链表部分反转也是一样的，不过链表部分反转之后通过穿针引线的方式串回原链表即可，不需要进行反转。
具体实现就是，首先切割出子链表，然后反转子链表，最后串起来。切割子链表这里的操作需要注意、
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { // 虚拟头 ListNode dummy = new ListNode(); dummy.next = head; ListNode leftNode = dummy; // 获得左节点右节点和边界节点 for (int i = 0; i &amp;lt; left - 1; i++) { leftNode = leftNode.</description></item><item><title>Leetcode-206-反转链表</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>题目链接：
https://leetcode-cn.com/problems/reverse-linked-list/
tag：链表
链表反转的关键在于记录前驱节点 prev，想到这点就很快能做出来。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; while (current != null) { ListNode next = current.</description></item><item><title>Leetcode-082-删除链表中的重复元素II</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-082-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</link><pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-082-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</guid><description>题目链接：
https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/
tag：链表 虚拟头
如果下两个节点值相等，就证明有连续相等的值，然后进行顺序遍历直到找到不相等的值作为下一个节点。
这题更加体现虚拟头的作用，可以直接开始判断，如果不使用虚拟头则感觉要分情况讨论。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; ListNode current = dummy; // 循环内的流程先画好图想清楚，基本画好图根据图写好代码，后面就是一些细节问题 while (current.</description></item><item><title>Leetcode-083-删除排序链表中的重复元素</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link><pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid><description>题目链接：
https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/
tag：链表
简单，不需要很多技巧，判断后面的节点是否与当前节点值相等，如果相等就删除，遍历一遍即可。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode cur = head; while (cur != null) { // 如果下一个节点与当前节点值相等，则删除 if (cur.next !</description></item><item><title>Leetcode-21-合并两个有序链表</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description>题目链接：
https://leetcode-cn.com/problems/merge-two-sorted-lists/
tag：归并排序 链表 虚拟头
链表和数组是类似的，所以合并两个有序链表可以借鉴合并两个有序数组的方法，不难想到使用归并排序的策略。
做链表题是时刻考虑判空，考虑到传入的 ListNode 可能为 null，即返回的链表可能为 null，使用虚拟头解决来避免判空。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 虚拟头 ListNode result = new ListNode(); ListNode current = result; // 以下就是归并操作 ListNode left = l1; ListNode right = l2; while (left !</description></item><item><title>LinkedList</title><link>https://Jimall.github.io/posts/leetcode/topic/01.%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/topic/01.%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</guid><description>链表结构 线性结构
public class ListNode { int val; ListNode next; } 链表的基本操作 要熟悉链表的常用操作和各自复杂度。
插入操作：O(N)
删除操作：O(N)
查找操作：O(N)
要知道为什么是这样的复杂度。
解题注意事项 解题时心中要时刻默念：
先画图，再解题 时刻考虑判空 链表题只要能画出图，解题的方向基本不会出问题，容易出错的地方在判空上。
解题技巧 链表常用的解题技巧：
虚拟头 快慢指针 虚拟头 虚拟头在返回的链表头结点可能为 null 的时候可以用上，利用虚拟头可以避免对返回值判空。
虚拟头的常见模式如下，先创建一个链表，然后将链表头和输入链表连接：
ListNode dummy = new ListNode(); // 将虚拟头和输入链表连接 dummy.next = input; 然后进行各种操作之后返回虚拟头的下一个节点，这样即使 input 全部删除了，即返回值为 null，也不用作判断。
return dummy.next; Leetcode-082
题目推荐 21.合并两个有序链表——题解✅Leetcode✅ 82.删除排序链表中的重复元素II——题解✅Leetcode✅ 83.删除排序链表中的重复元素——题解✅Leetcode✅ 86.分隔链表——题解✅Leetcode✅ 92.反转链表 II——题解✅Leetcode✅ 138.复制带随机指针的链表——题解Leetcode 141.环形链表——题解Leetcode 142.环形链表 II——题解Leetcode 143.重排链表——题解Leetcode 148.排序链表——题解Leetcode 206.反转链表——题解✅Leetcode✅ 234.回文链表——题解Leetcode</description></item></channel></rss>