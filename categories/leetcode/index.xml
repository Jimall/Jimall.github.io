<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcode on BLOG</title><link>https://Jimall.github.io/categories/leetcode/</link><description>Recent content in Leetcode on BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 13 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://Jimall.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode-082-删除链表中的重复元素II</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-082-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</link><pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-082-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</guid><description>/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; ListNode cur = dummy; while (cur.next != null &amp;amp;&amp;amp; cur.next.next !</description></item><item><title>Leetcode-083-删除排序链表中的重复元素</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link><pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid><description>https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/
简单，不需要很多技巧，判断后面的节点是否与当前节点值相等，如果相等就删除，遍历一遍即可。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode cur = head; while (cur != null) { // 如果下一个节点与当前节点值相等，则删除 if (cur.next != null &amp;amp;&amp;amp; cur.</description></item><item><title>Leetcode-21-合并两个有序链表</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description>tag：归并排序、虚拟头
链表和数组是类似的，所以合并两个有序链表可以借鉴合并两个有序数组的方法，不难想到使用归并排序的策略。
同时做链表题是时刻考虑判空，考虑到传入的 ListNode 可能为 null，即头可能为 null，使用虚拟头解决来避免麻烦的判空。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 虚拟头 ListNode result = new ListNode(); ListNode current = result; // 以下就是归并操作 ListNode left = l1; ListNode right = l2; while (left !</description></item></channel></rss>