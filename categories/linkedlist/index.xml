<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LinkedList on BLOG</title><link>https://Jimall.github.io/categories/linkedlist/</link><description>Recent content in LinkedList on BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://Jimall.github.io/categories/linkedlist/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode-092-反转链表II</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</guid><description>题目链接：
https://leetcode-cn.com/problems/reverse-linked-list-ii/
tag：链表
在串中，部分反转可以通过先部分反转，再整体反转的思路来进行。链表部分反转也是一样的，不过链表部分反转之后通过穿针引线的方式串回原链表即可，不需要进行反转。
具体实现就是，首先切割出子链表，然后反转子链表，最后串起来。切割子链表这里的操作需要注意、
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { // 虚拟头 ListNode dummy = new ListNode(); dummy.next = head; ListNode leftNode = dummy; // 获得左节点右节点和边界节点 for (int i = 0; i &amp;lt; left - 1; i++) { leftNode = leftNode.</description></item><item><title>Leetcode-206-反转链表</title><link>https://Jimall.github.io/posts/leetcode/problem/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/posts/leetcode/problem/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>题目链接：
https://leetcode-cn.com/problems/reverse-linked-list/
tag：链表
链表反转的关键在于记录前驱节点 prev，想到这点就很快能做出来。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; while (current != null) { ListNode next = current.</description></item></channel></rss>