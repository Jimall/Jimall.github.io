<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SpringFramework on BLOG</title><link>https://Jimall.github.io/categories/springframework/</link><description>Recent content in SpringFramework on BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 03 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://Jimall.github.io/categories/springframework/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring IoC 组件详解</title><link>https://Jimall.github.io/tech/posts/java/spring/ioc/spring%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/java/spring/ioc/spring%E7%AC%94%E8%AE%B0/</guid><description>Spring 有两大核心机制：
IoC (Inverse of Control, 控制反转) AOP (Aspect-Oriented Programming, 面向切面编程) 学习 Spring 的核心（单指 Spring 本身，不包括别的组件）就在于学习理解这两大核心机制。
这篇文章我们来讲讲 IoC。
IoC IoC 是 Spring 的核心机制。
什么是 IoC？ IoC (Inversion of Control)，即“控制反转”。它不是一种技术，而是一种设计思想。在 Java 开发中，IoC 意味着将你设计好的对象交给容器控制，而不是在你的对象内部控制（控制的意思是说对象内部需要通过 new 等方式创建依赖对象，需要我们自己进行创建）。
如何理解好 IoC 呢？理解好 Ioc 的关键是要明确”谁控制谁？控制什么？为何是反转？哪些方面反转了？”：
”谁控制谁？控制什么？“：在传统 Java SE 程序设计中，我们直接在对象内部通过 new 创建对象，是对象主动去创建依赖对象，而 IoC 通过一个专门的容器（称为 IoC 容器）来创建这些对象；谁控制谁？IoC 容器控制了对象；控制什么？控制了外部资源获取（不只是对象包括比如文件等）。
“为何是反转？哪些方面反转了？”：有反转就有正转，传统应用程序由我们自己在程序中主动控制去获取依赖对象，也就是正转，而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取反转。
所以控制反转的意思就是，IoC 容器控制对象，让依赖对象的获取反转。
IoC 能做什么？ IoC 不是一种技术，而是一种设计思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试。有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。
IoC 很好的体现了面向对象设计法则中的好莱坞法则：“别找我们，我们找你”，即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。
DI DI (Dependency Injection) 依赖注入。这也是 Spring 中的一个重要概念。</description></item><item><title>Spring结合Junit进行单元测试</title><link>https://Jimall.github.io/tech/posts/java/spring/spring%E7%BB%93%E5%90%88junit%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate><guid>https://Jimall.github.io/tech/posts/java/spring/spring%E7%BB%93%E5%90%88junit%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>由于 Spring 各种注解的使用需要结合 xml 配置文件，所以单元测试没有办法直接写，需要引入 Spring 对单元测试的支持。下面讲讲详细步骤：
引入 Spring-test 和 junit test 依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.13&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.9.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 在测试类中添加 @RunWith 和 @ContextConfiguration 注解
@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&amp;quot;classpath:spring.xml&amp;quot;) public class StudentTest { @Autowired public Student student; @Test public void testStudentCreation() { System.out.println(student); } } 这样就可以正常使用了，需要注意的是，spring.xml 中需要配置才能使用 @Autowired 等注解：
&amp;lt;context:component-scan base-package=&amp;quot;org.example&amp;quot;/&amp;gt; （同时 xml 文件头还需要引入 context 相关的域，alt+enter 即可）</description></item></channel></rss>